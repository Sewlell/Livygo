<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Livygo - Question</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f4f4f4;
            position: relative;
        }

        /* Progress Bar */
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: #eee;
            z-index: 999;
        }

        .progress-bar {
            height: 100%;
            background-color: #8B0000;
            transition: width 0.3s ease;
        }

        /* Cutscene Styling */
        .cutscene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .cutscene-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .cutscene-content {
            font-size: 2rem;
            text-align: center;
            max-width: 800px;
            line-height: 1.5;
            z-index: 1000; /* Ensure this is higher than activity */
            pointer-events: auto; /* Enable clicks */
        }

        .skip-indicator {
            position: absolute;
            bottom: 2rem;
            animation: pulse 1.5s infinite;
            opacity: 0.7;
            font-size: 1.2rem;
        }

        /* Activity Styling */
        .activity {
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
            width: 90%;
            max-width: 600px;
            z-index: 1; /* Keep behind cutscene */
        }

        .activity.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* Question Styling */
        .question {
            font-size: 1.5rem;
            margin-bottom: 2rem;
        }

        .options {
            display: grid;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        button {
            padding: 1rem 2rem;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px);
        }

        input {
            padding: 1rem;
            width: 100%;
            margin: 1rem 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
        }

        /* Error Styling */
        .global-error {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ffebee;
            color: #b71c1c;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }

        @keyframes pulse {
            0% { transform: translateY(0); opacity: 0.7; }
            50% { transform: translateY(-5px); opacity: 1; }
            100% { transform: translateY(0); opacity: 0.7; }
        }

        .global-feedback {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 1rem 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s ease, fadeOut 1s ease 1s;
            color: white;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .global-feedback.correct {
            background-color: #4CAF50;
            border: 2px solid #388E3C;
        }

        .global-feedback.incorrect {
            background-color: #d32f2f;
            border: 2px solid #b71c1c;
        }

        .global-feedback.info {
            background-color: #dedede;
            border: 2px solid #939393;
            color: black;
        }

        .global-feedback::before {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="black"><path d="M1 21h22L12 2 1 21zm12-3h-2v-2h2v2zm0-4h-2v-4h2v4z"/></svg>');
            content: '';
            display: inline-block;
            width: 24px;
            height: 24px;
            background-size: contain;
            background-repeat: no-repeat;
        }

        .global-feedback.correct::before {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>');
        }

        .global-feedback.incorrect::before {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>');
        }

        @keyframes slideIn {
            from { top: -50px; opacity: 0; }
            to { top: 20px; opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Add warning feedback style */
        .global-feedback.warning {
            background-color: #FFC107;
            border: 2px solid #FFA000;
            color: #000;
        }

        .word-block {
            display: inline-block;
            min-width: auto;
            padding: 6px 10px;
            font-size: 1rem;
            background: #8B0000;
            color: white;
            border-radius: 4px;
            margin: 4px;
            cursor: pointer;
            text-align: center;
        }

        .blocks-tray {
            background: #f8f8f8;
            min-height: 60px;
            border-radius: 8px;
        }

        .sentence-builder {
            background: #fff;
            min-height: 80px;
            margin-top: 1rem;
            border-radius: 8px;
            border: 2px dashed #ccc;
            margin-bottom: 1.2rem !important;
        }

        .blocks-tray, .sentence-builder {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 1rem;
        }

        .answer-area {
            min-height: 60px;
            border: 2px dashed #ccc;
            margin: 1rem 0;
        }

        .input-mode {
            margin-top: 1rem;
            padding: 1rem;
            background: #f8f8f8;
            border-radius: 8px;
            min-height: 80px;
        }

        .audio-player-container {
            text-align: center;
            margin: 1rem 0;
        }

        #type3InputContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        #type3TextInput {
            width: 300px;
            padding: 12px;
            font-size: 1.1rem;
            margin: 0.5rem 0;
        }

        #type3Submit {
            padding: 12px 24px;
            width: fit-content;
            margin: 0.5rem 0;
        }

        .type3-question-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .type3-options {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 1rem 0;
        }

        #textContainer input {
            width: 100%;
            max-width: 500px;
            padding: 12px;
            font-size: 1.1rem;
        }

        .kanji-container {
            max-width: 600px;
            margin: 2rem auto;
            text-align: center;
        }

        .writing-area {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 1rem auto;
            border: 2px solid #8B0000;
            border-radius: 8px;
        }

        #kanjiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(to right, #acacac 1px, transparent 1px),
                            linear-gradient(to bottom, #acacac 1px, transparent 1px);
            background-size: 30px 30px;
            z-index: 1;
        }

        .kanji-controls {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .ocr-settings {
            margin: 1rem 0;
            color: #666;
        }

        .kanji-controls button:disabled {
            background-color: #cccccc !important;
            transform: none !important;
            pointer-events: none !important;
        }

        /* Type 5 Specific Styling */
        .type5-blank {
            width: 120px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-bottom: 2px solid #8B0000;
            padding-bottom: 8px;
        }

        .type5-answer-slot {
            background: #f0f0f0;
            min-height: 36px;
            border-radius: 4px;
            padding: 4px;
        }

        .blank-container {
            position: relative;
            display: inline-block;
            vertical-align: middle;
            flex-direction: column;
            margin: 0 8px;
            min-height: 60px;
        }

        .blank-number {
            position: absolute;
            top: -24px;
            left: 50%;
            transform: translateX(-50%);
            color: #666;
            font-size: 0.8rem;
            margin-bottom: 8px;
        }

        .text-input-group {
            margin: 15px 0;
            display: flex;
            align-items: center;
            gap: 4px;
        }

        .input-number {
            font-weight: bold;
            color: #8B0000;
            min-width: 30px;
        }

        .draggable {
            background-color: #8B0000;
            cursor: grab;
            transition: transform 0.2s;
        }

        .dropped-block {
            background-color: #666 !important;
            cursor: pointer !important;
            opacity: 0.9;
            transform: scale(0.95);
            top: -6px;
            margin: 8px 0;
        }

        .type5-instruction {
            color: #444;
            font-size: 1.2rem;
            margin-bottom: 1.5rem !important;
        }

        /* Translation text spacing */
        #type5Container .question {
            margin-bottom: 1.2rem;
            border: none;
            padding-bottom: 0;
             text-align: left;
             line-height: 1.8;
        }

        /* Style the translation paragraph specifically within Type 5 */
        #type5Container > p,
        #type5Container .type5-left-column > p {
            margin-top: 1rem;  
            margin-bottom: 1rem; 
            padding: 0.5rem 0;
            font-style: italic;
            color: #555;
            border: none;
            text-align: left;
        }

        /* Ensure instruction text also has appropriate spacing */
         #type5Container .type5-instruction {
             color: #444;
             font-size: 1.2rem;
             margin-bottom: 1.5rem !important;
             text-align: center;
         }

        .input-mode-selector {
            margin: 1.2rem 0;
        }

        .question-origin {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 0.8rem;
            z-index: 1000;
            color: white;
            opacity: 0;
            transform: translateY(-20px);
            transition: all 0.3s ease;
            pointer-events: none;
        }
        .question-origin.visible {
            opacity: 0.9;
            transform: translateY(0);
        }
        .question-origin.relearn {
            background: #FFA500;
            box-shadow: 0 2px 4px rgba(255,165,0,0.3);
        }
        .question-origin.new {
            background: #4CAF50;
            box-shadow: 0 2px 4px rgba(76,175,80,0.3);
        }


        /* --- Type 5 Split Layout Styles --- */
        .type5-split-layout {
            display: flex;
            gap: 25px; /* Increased space */
            align-items: flex-start;
            width: 100%;
            max-width: 1100px; /* Wider max width for split view */
            margin: 1rem auto; /* More margin */
        }

        .type5-left-column,
        .type5-right-column {
            flex: 1; /* Still take half space */
            /* Remove fixed max-height, let content determine height */
            /* max-height: 70vh; */
            overflow-y: auto; /* Scroll if content exceeds viewport */
            padding: 20px;
            border-radius: 8px;
        }

        .type5-left-column {
            background-color: #fff;
            border: 1px solid #eee;
            text-align: left;
            line-height: 1.8; /* Increase line height */
        }
        .type5-left-column .question { /* Style the container holding the sentence/paragraph */
            font-size: 1.1rem; /* Keep font size reasonable */
            margin-bottom: 0; /* Remove bottom margin if not needed */
            text-align: left;
            padding-bottom: 0;
            border-bottom: none;
        }
        .type5-left-column p { /* Style paragraphs within the text if you have them */
             margin-bottom: 1em; /* Add space between paragraphs */
             /* Ensure inline elements align well */
             vertical-align: middle;
         }
         /* Blank Container Styling */
         .type5-left-column .blank-container {
             display: inline-block; /* Allows it to sit within text */
             vertical-align: bottom; /* Align bottom with text */
             margin: 0 4px; /* Small horizontal margin */
             min-height: auto; /* Reset min-height, let content dictate */
             position: relative; /* Keep for number positioning */
             white-space: normal; /* Allow content inside blank to wrap if needed */
         }
         /* The actual blank input area */
         .type5-left-column .type5-blank {
             display: inline-flex; /* Use flex for centering content */
             align-items: center;
             justify-content: center;
             width: 110px; /* Adjust width as needed */
             min-height: 28px; /* Set a minimum height */
             height: auto; /* Allow height to grow slightly with content */
             padding: 2px 4px; /* Padding inside the blank */
             font-size: 1rem; /* Match surrounding text */
             border-bottom-width: 2px; /* Keep underline */
             border-radius: 0; /* Remove other borders */
             background-color: #f0f0f0; /* Keep light background */
             vertical-align: bottom; /* Align with text */
         }
         /* Number above blank */
          .type5-left-column .blank-number {
             font-size: 0.7rem;
             top: -18px; /* Adjust position relative to blank */
             left: 50%;
             transform: translateX(-50%);
         }
          /* Style for block inside the blank */
         .type5-left-column .type5-blank .dropped-block {
             font-size: 0.95rem; /* Slightly smaller if needed */
             padding: 2px 6px;
             margin: 0; /* Remove default margin */
             top: 0; /* Remove offset */
             transform: none; /* Remove scaling */
             max-width: 100%; /* Prevent overflow */
             overflow: hidden;
             text-overflow: ellipsis;
             white-space: nowrap;
         }


        .type5-right-column {
            background-color: #f8f8f8;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding-top: 10px; /* Less top padding */
             max-height: 80vh; /* Add max-height to right column */
             overflow-y: auto; /* Scroll controls if needed */
        }
        .type5-right-column .input-mode-selector,
        .type5-right-column #type5BlocksMode,
        .type5-right-column #type5TextMode {
            width: 100%;
            margin-top: 0.5rem; /* Less margin */
        }
         .type5-right-column .blocks-tray {
             min-height: 150px; /* Good space for blocks */
             padding: 15px;
         }
         .type5-right-column .text-input-group {
             justify-content: center;
         }
         .type5-right-column button[onclick="validateType5Answer()"] {
            margin-top: auto; /* Push submit button towards bottom */
            margin-bottom: 10px; /* Some space at bottom */
            width: auto;
            padding: 0.8rem 1.5rem;
         }
    </style>
</head>
<body>
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <div class="cutscene-container" id="cutsceneContainer">
        <div class="cutscene-content" id="cutsceneContent"></div>
        <div class="skip-indicator">▼ Click to continue ▼</div>
    </div>

    <div class="activity" id="activity"></div>

    <div class="question-origin" id="questionOrigin"></div>

    <script src="https://unpkg.com/wanakana@5.3.1/wanakana.min.js"></script>
    <script>
        // Configuration
        const urlParams = new URLSearchParams(window.location.search);
        const currentCode = urlParams.get('code') || '001001';
        // const basePath = urlParams.get('basePath') || '/courses/ES-en/General/001/'; // Replaced by dynamic path finding
        const lang = urlParams.get('lang') || 'JP-en';
        const subcourse = urlParams.get('subcourse') || 'General';

        // Will be determined dynamically
        let dynamicBasePath = '';

        let questionsPerLesson = 5;
        let questionsCompleted = 0;
        let currentCutsceneIndex = 0;
        let cutscenes = [];
        let isCutsceneActive = false;
        let currentQuestion = null;

        // Data storage
        let type1Data = [];
        let allType1Data = []; 
        let type2Data = [];
        let type3Data = [];
        let type4Data = [];
        let type5Data = [];
        let type6Data = [];
        let enableOCR = true;
        let enabledQuestionTypes = ['type1', 'type2', 'type3', 'type4']; // Default, will be overridden
        let relearnType1 = JSON.parse(localStorage.getItem(`relearnType1_${lang}`)) || [];
        let relearnType2 = JSON.parse(localStorage.getItem(`relearnType2_${lang}`)) || [];
        let lessonProgress = {}; // Will hold the array from localStorage
        let currentLesson = null; // Will hold the specific lesson config object
        let pathwayStructure = [];
        // let newQuestionRatio = 0.8; // Replaced by pathway/lesson settings
        let initialConfigLogged = false;

        // Type 6 stuff
        let strokes = [];
        let isDrawing = false;
        let canvas, ctx;
        let isHandwriteLocked = false;
        let currentTimeout = null;
        let requiredStrokeAccuracy = 75;

        document.addEventListener('DOMContentLoaded', () => {
            const storedProgress = JSON.parse(localStorage.getItem(`lessonProgress_${lang}`)) || [];
            lessonProgress = storedProgress; // Keep the full array accessible if needed

            // Load pathway structure first
            fetch(`/courses/${lang}/${subcourse}/pathway_structure.json`)
            .then(response => {
                if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
                return response.json();
            })
            .then(fetchedPathway => {
                pathwayStructure = fetchedPathway;

                // Find the current section and its settings/path
                const numericCode = parseInt(currentCode);
                const section = pathwayStructure.find(s =>
                    s.addressMap && s.addressMap.some(range =>
                        numericCode >= parseInt(range.rangeStart) && // Ensure comparison is numeric
                        numericCode <= parseInt(range.rangeEnd)
                    )
                );

                if (!section) {
                    throw new Error(`Section containing code ${currentCode} not found in pathway_structure.json`);
                }

                const matchedRange = section.addressMap.find(range =>
                    numericCode >= parseInt(range.rangeStart) &&
                    numericCode <= parseInt(range.rangeEnd)
                );

                if (!matchedRange || !matchedRange.path) {
                     // Fallback to defaultAddress if specific range or path missing
                    dynamicBasePath = section.defaultAddress || `/courses/${lang}/${subcourse}/${section.code}/`; // Use default or construct
                    console.warn(`No specific path found for ${currentCode} in section ${section.code}, using: ${dynamicBasePath}`);
                 } else {
                    dynamicBasePath = matchedRange.path;
                 }

                const pathwaySettings = section.settings || {}; // Get pathway settings or empty object

                // Set enabled question types (prioritize section settings)
                enabledQuestionTypes = pathwaySettings.enabledQuestionTypes || enabledQuestionTypes; // Use pathway's or keep default

                // Load lesson progress JSON AFTER finding the path
                return fetch(`${dynamicBasePath}lesson_progress.json`)
                    .then(res => {
                         if (!res.ok) {
                            if (!initialConfigLogged) console.warn(`lesson_progress.json not found at ${dynamicBasePath}. Using defaults.`);
                            return []; // Return empty array if not found
                        }
                        return res.json();
                     })
                    .then(progressData => {
                         // Ensure progressData is array
                        if (!Array.isArray(progressData)) {
                            if (!initialConfigLogged) console.warn("Fetched lesson_progress.json is not an array. Using empty array.");
                            progressData = [];
                        }

                        // --- Determine currentLesson Configuration (v3 - Prioritize Fetched Config) ---
                        console.log("--- Determining lesson config ---");
                        console.log("Current Code:", currentCode);
                        console.log("Fetched progressData:", progressData);
                        console.log("Stored progress (localStorage):", storedProgress);
                        console.log("Pathway Settings:", pathwaySettings);

                        // 1. Base Configuration: Default -> Pathway -> Fetched Specific
                        const defaultProgressEntry = progressData.find(p => p.code === 'default') || {
                            code: 'default', title: 'Default Lesson', total: 5, current: 1,
                            questionsPerLesson: 10, practicecirc: false, relearnpool: true,
                            // Add default ratio if needed, otherwise it relies on pathway/specific
                            // questionRatio: [25, 25, 25, 25] // Example default if none exists elsewhere
                        };
                        if (!initialConfigLogged) console.log("Step 1: Default Entry", defaultProgressEntry);

                        let baseLessonConfig = { ...defaultProgressEntry, ...pathwaySettings };
                        if (!initialConfigLogged) console.log("Step 2: + Pathway Settings", baseLessonConfig);

                        const fetchedSpecificLesson = progressData.find(p => p.code === currentCode);
                        if (fetchedSpecificLesson) {
                            baseLessonConfig = { ...baseLessonConfig, ...fetchedSpecificLesson };
                            if (!initialConfigLogged) console.log("Step 3: + Fetched Specific Lesson Data", baseLessonConfig);
                        } else {
                            if (!initialConfigLogged) console.log("No specific lesson config found in fetched JSON for", currentCode);
                            // If no specific config, ensure title/code reflect the current lesson
                            baseLessonConfig.title = pathwaySettings?.title || defaultProgressEntry.title || `Lesson ${currentCode}`;
                        }

                        // --- Ensure essential config fields have fallbacks ---
                         baseLessonConfig.questionsPerLesson = baseLessonConfig.questionsPerLesson || 10;
                         baseLessonConfig.total = baseLessonConfig.total || 5;
                         baseLessonConfig.current = baseLessonConfig.current || 1; // Default progress start
                         baseLessonConfig.practicecirc = baseLessonConfig.practicecirc === true; // Ensure boolean
                         baseLessonConfig.relearnpool = baseLessonConfig.relearnpool !== false; // Default true
                         // baseLessonConfig.questionRatio = baseLessonConfig.questionRatio || null; // Keep null if not defined

                        // 2. Find Progress State from LocalStorage
                        const storedSpecificLesson = storedProgress.find(lp => lp.code === currentCode);
                        let currentProgressValue = 1; // Default starting progress
                        if (storedSpecificLesson && typeof storedSpecificLesson.current === 'number') {
                            currentProgressValue = storedSpecificLesson.current;
                            if (!initialConfigLogged) console.log("Found progress state in LocalStorage:", { current: currentProgressValue });
                        } else {
                            if (!initialConfigLogged) console.log("No specific progress state found in LocalStorage for", currentCode, ". Starting at 1.");
                        }

                        // 3. Combine Base Config with Progress State
                        currentLesson = {
                            ...baseLessonConfig,        // Take all config from JSON/Pathway/Default merge
                            code: currentCode,          // Ensure correct code
                            current: currentProgressValue // Override 'current' with value from localStorage (or default 1)
                        };
                        // --- End Configuration ---

                        if (!initialConfigLogged) {
                            console.log('--- Final Effective Lesson Config (Run Once) ---:', currentLesson);
                            console.log('Final questionRatio (Run Once):', currentLesson.questionRatio);
                            initialConfigLogged = true; // Set flag after logging everything once
                        }

                        // Update global variables based on final config
                        questionsPerLesson = currentLesson.questionsPerLesson;
                        requiredStrokeAccuracy = currentLesson?.settings?.requiredStrokeAccuracy || 75;

                        // --- Save Updated State to LocalStorage ---
                        // Always save the latest combined state (config + current progress)
                        // Find if an entry already exists to update it, otherwise push.
                        const existingStorageIndex = storedProgress.findIndex(lp => lp.code === currentCode);
                        if (existingStorageIndex > -1) {
                            // Update existing entry - focus on merging progress state if needed in future
                            storedProgress[existingStorageIndex] = { ...storedProgress[existingStorageIndex], ...currentLesson }; // Overwrite with latest combined state
                            console.log("Updated lesson state in localStorage for", currentCode);
                        } else {
                            // Add new entry
                            storedProgress.push(currentLesson);
                            console.log("Added new lesson state to localStorage for", currentCode);
                        }
                        // Save the potentially modified storedProgress array
                        localStorage.setItem(`lessonProgress_${lang}`, JSON.stringify(storedProgress));
                        // --- End Save State ---


                        // Load actual question data using the determined dynamicBasePath and enabled types
                        return Promise.all([ // Make sure this Promise.all is still returned
                             fetch(`${dynamicBasePath}cutscenes.json`).then(res => res.ok ? res.json() : { sequence: [] }),
                             enabledQuestionTypes.includes('type1') ? fetch(`${dynamicBasePath}type1_vocabulary.json`).then(res => res.ok ? res.json() : []).catch(() => []) : Promise.resolve([]),
                             enabledQuestionTypes.includes('type2') ? fetch(`${dynamicBasePath}type2_grammar.json`).then(res => res.ok ? res.json() : []).catch(() => []) : Promise.resolve([]),
                             enabledQuestionTypes.includes('type3') ? fetch(`${dynamicBasePath}type3_listening.json`).then(res => res.ok ? res.json() : []).catch(() => []) : Promise.resolve([]),
                             enabledQuestionTypes.includes('type4') ? fetch(`${dynamicBasePath}type4_sentence.json`).then(res => res.ok ? res.json() : []).catch(() => []) : Promise.resolve([]),
                             enabledQuestionTypes.includes('type5') ? fetch(`${dynamicBasePath}type5_context.json`).then(res => res.ok ? res.json() : []).catch(() => []) : Promise.resolve([]),
                             enabledQuestionTypes.includes('type6') ? fetch(`${dynamicBasePath}type6_characters.json`).then(res => res.ok ? res.json() : []).catch(() => []) : Promise.resolve([]),
                        ]);
                    });
            })
            .then(([cutsceneData, vocab, grammar, listening, sentence, type5, type6]) => {

                allType1Data = [...vocab];

                // --- Filter Questions Based on Lesson Config ---
                const baseCode = currentCode.split('-')[0]; // Usually the section code like '001'
                const pracLimitCode = currentLesson.praclimit || ''; // Get practice limit

                // Helper for filtering logic
                const filterLogic = (item) => {
                    // --- Robustness Check ---
                    if (!item || typeof item.code !== 'string') {
                         console.warn('Skipping item due to missing or invalid code:', item);
                         return false; // Skip items without a valid string code
                    }
                    // --- End Robustness Check ---

                    // Basic check: Does item code start with the section code?
                    if (!item.code.startsWith(baseCode)) return false;
                    // Practice Limit Check: If praclimit is set, compare item code against it
                    if (pracLimitCode && !CodeParser.compare(item.code, pracLimitCode)) {
                         return false;
                    }
                    return true; // Passes checks
                };

                // Apply filtering
                type1Data = vocab.filter(filterLogic);
                type2Data = grammar.filter(filterLogic);
                type3Data = listening.filter(item => filterLogic(item) && item.answers?.text && Array.isArray(item.answers.text));
                type4Data = sentence.filter(item => filterLogic(item) && item.blocks && Array.isArray(item.blocks));
                type5Data = type5.filter(filterLogic);
                // Type 6 filtering (often specific to circle code, handle carefully)
                type6Data = type6.filter(item => {
                    if (!filterLogic(item)) return false;
                    // Additional check if it's Kanji specific - might need refinement based on guidcode format
                     if (item.guidcode && item.guidcode.startsWith('KAN-')) {
                         const kanjiCircleCode = item.guidcode.split('-')[1];
                         return kanjiCircleCode === currentCode; // Only match exact circle for Kanji? Adjust if needed.
                     }
                    return true; // If not KAN- or no guidcode, include if base filter passes
                });
                // --- End Filtering ---


                console.log('Filtered questions:', {
                    type1: type1Data.length, type2: type2Data.length, type3: type3Data.length,
                    type4: type4Data.length, type5: type5Data.length, type6: type6Data.length
                });

                // Handle cutscenes
                const currentCutscene = cutsceneData.find(c => c.code === currentCode);
                if (currentCutscene?.nocutsc) {
                    const cutsceneElem = document.getElementById('cutsceneContainer');
                    if (cutsceneElem) cutsceneElem.remove();
                    startLesson();
                } else if (currentCutscene?.sequence && currentCutscene.sequence.length > 0) {
                    cutscenes = currentCutscene.sequence.flatMap(scene =>
                        scene.lines.join('\n').split(/\/{3,}/).map(part => ({
                            lines: part.trim().split('\n')
                        }))
                    );
                    showCutscene(0);
                } else {
                     const cutsceneElem = document.getElementById('cutsceneContainer');
                     if (cutsceneElem) cutsceneElem.remove();
                     startLesson();
                }
            })
            .catch(error => {
                console.error("Loading or Initialization error:", error);
                showError(`Data load failed: ${error.message}. Redirecting...`);
                setTimeout(() => window.location.href = 'mainnightly.html', 3000);
            });
        });


        // Cutscene handling (Keep existing functions: showCutscene, typeWriter, endCutscene)
        function showCutscene(index) {
            const cutsceneContainer = document.getElementById('cutsceneContainer');
            if (!cutsceneContainer || index >= cutscenes.length) {
                endCutscene();
                return;
            }

            const scene = cutscenes[index];
            const contentContainer = document.getElementById('cutsceneContent');
            contentContainer.innerHTML = ''; // Clear previous
            typeWriter(contentContainer, scene.lines, 0);
        }

        function typeWriter(container, lines, lineIndex, charIndex = 0) {
            if (lineIndex >= lines.length) {
                // Add click listener to parent to advance
                container.parentElement.addEventListener('click', () => {
                    currentCutsceneIndex++;
                    showCutscene(currentCutsceneIndex);
                }, { once: true });
                return;
            }

            const lineDiv = document.createElement('div');
            lineDiv.className = 'cutscene-line';
            container.appendChild(lineDiv);

            let timeoutId = null; // To store the timeout

            const processChar = () => {
                if (charIndex < lines[lineIndex].length) {
                    lineDiv.textContent += lines[lineIndex][charIndex];
                    charIndex++;
                    timeoutId = setTimeout(processChar, 50); // Adjust speed if needed
                } else {
                    // Line finished, move to next line
                    lineIndex++;
                    charIndex = 0;
                    typeWriter(container, lines, lineIndex);
                }
            };

            // Click handler to skip current line/advance scene
            const skipHandler = () => {
                 clearTimeout(timeoutId); // Stop typing immediately
                 // If current line wasn't finished, complete it instantly
                 if (charIndex < lines[lineIndex].length) {
                    lineDiv.textContent = lines[lineIndex]; // Show full line
                    // Now, immediately call typeWriter for the *next* line
                    lineIndex++;
                    charIndex = 0;
                    typeWriter(container, lines, lineIndex);
                 } else {
                     // Line was already finished, just advance the scene
                    currentCutsceneIndex++;
                    showCutscene(currentCutsceneIndex);
                 }
            };

            container.parentElement.addEventListener('click', skipHandler, { once: true });

            processChar(); // Start typing
        }

        function endCutscene() {
            const cutsceneContainer = document.getElementById('cutsceneContainer');
            if (cutsceneContainer) {
                cutsceneContainer.classList.add('hidden');
                // Use transitionend event for safer removal
                cutsceneContainer.addEventListener('transitionend', () => {
                    cutsceneContainer.remove();
                    startLesson();
                }, { once: true });
                // Fallback timeout in case transitionend doesn't fire
                setTimeout(() => {
                    if (document.body.contains(cutsceneContainer)) {
                         cutsceneContainer.remove();
                         startLesson();
                    }
                }, 600); // Slightly longer than CSS transition
            } else {
                 startLesson(); // If already removed, just start
            }
        }


        // Lesson handling
        function startLesson() {
            document.getElementById('activity').classList.add('active');
            // <<< NEW: Initialize lesson stats for feedback tracking >>>
            window.lessonStats = {
                servedActualRelearn: false,
                shownUnlimitedSwitchFeedback: false
            };
            generateNextQuestion();
        }

        // --- REVISED generateNextQuestion ---
        function generateNextQuestion() {
            console.log("=== GENERATE NEXT QUESTION START ===");
            performance.mark("questionStart");
            window.isAnswered = false; // Reset answered flag
            disableButtons(true); // Disable UI

            try {
                if (questionsCompleted >= questionsPerLesson) {
                    completeLesson();
                    return;
                }

                // --- Determine Focus: Handwriting or Standard ---
                const isHandwritingFocus = currentLesson.handwritecirc === true; // Explicit check for true
                let effectivePracticeCirc = !isHandwritingFocus && currentLesson.practicecirc === true; // Practice only if not handwriting

                // --- Practice Circle Check & Override (Only if not handwriting focus) ---
                if (effectivePracticeCirc && currentLesson.allowUnlimitedPracticePool) { // Already excludes handwriting focus
                    const newQuestionsForThisCircle = [
                        ...type1Data, ...type2Data, ...type3Data,
                        ...type4Data, ...type5Data // Exclude type 6 for this check
                    ].filter(q => q && typeof q.code === 'string' && q.code === currentCode); // Check against the SPECIFIC circle code

                    if (newQuestionsForThisCircle.length > 0) {
                        showFeedback(
                            "Practice mode on, but new questions found for this circle. Standard lesson mode activated.",
                            "warning"
                        );
                        effectivePracticeCirc = false; // Override practice mode
                    }
                }
                // --- End Practice Circle Check ---

                // 1. Determine Question Source Logic & Allowed Types
                const useRelearn = currentLesson.relearnpool !== false; // Default to true
                const defaultNewRatio = pathwayStructure.settings?.newQuestionRatio ?? 0.8; // Use pathway or fallback

                let totalNew = 0;
                let totalRelearn = 0;
                let currentAllowedTypes = []; // Which types are allowed for *this* question

                // --- START: Full logic for determining question counts and allowed types ---
                if (isHandwritingFocus) {
                    // --- Handwriting Circle ---
                    console.log("Handwriting focus active.");
                    currentAllowedTypes = ['type6']; // ONLY Type 6
                    // For handwriting, all questions come from its 'new' pool (of Type 6)
                    // No 'relearn' in the traditional sense for handwriting from relearnType1/2
                    totalNew = questionsPerLesson;
                    totalRelearn = 0;
                    if (!enabledQuestionTypes.includes('type6') || type6Data.length === 0) {
                        // This error should be caught later if no question is found.
                        // Or you can throw here if you prefer immediate stop.
                        console.warn("Handwriting circle active, but Type 6 is disabled or has no questions in type6Data.");
                    }
                } else {
                    // --- Standard Circle (Focused or Practice) ---
                    currentAllowedTypes = enabledQuestionTypes.filter(type => type !== 'type6'); // Exclude Type 6

                    if (effectivePracticeCirc) {
                        // Valid Practice Circle: Only Relearn (if enabled) from non-Type 6 types
                        totalNew = 0;
                        totalRelearn = useRelearn ? questionsPerLesson : 0;
                        if (!useRelearn) {
                            console.warn("Practice circle with relearnpool=false active. May result in no questions if actual relearn pools are empty and unlimited is off.");
                        }
                    } else if (!useRelearn) {
                        // Standard Lesson, Relearn Disabled: All New (from non-Type 6 types)
                        totalNew = questionsPerLesson;
                        totalRelearn = 0;
                    } else {
                        // Standard Lesson, Relearn Enabled: Use Ratio (from non-Type 6 types)
                        totalNew = Math.floor(questionsPerLesson * defaultNewRatio);
                        totalRelearn = questionsPerLesson - totalNew;
                    }
                }
                // --- END: Full logic for determining question counts and allowed types ---

                console.log("Question split logic:", { totalNew, totalRelearn, useRelearn, effectivePracticeCirc, isHandwritingFocus, allowUnlimited: currentLesson.allowUnlimitedPracticePool });
                console.log("Allowed types for this question:", currentAllowedTypes);

                let questionPool = [];
                // Filter pools by allowed types FOR THIS QUESTION
                let availableNewPools = [
                    currentAllowedTypes.includes('type1') ? type1Data : [],
                    currentAllowedTypes.includes('type2') ? type2Data : [],
                    currentAllowedTypes.includes('type3') ? type3Data : [],
                    currentAllowedTypes.includes('type4') ? type4Data : [],
                    currentAllowedTypes.includes('type5') ? type5Data : [],
                    currentAllowedTypes.includes('type6') ? type6Data : [] // Include type6Data if 'type6' is in currentAllowedTypes
                ];

                let availableRelearnPools = [ // These are the *actual* relearn pools
                    currentAllowedTypes.includes('type1') ? relearnType1 : [],
                    currentAllowedTypes.includes('type2') ? relearnType2 : [],
                    [], [], [], [] // No relearn for type3-6 in this logic
                ];

                // 1. Add New Questions (if any)
                if (totalNew > 0) {
                    const useRatioForNew = !isHandwritingFocus && !effectivePracticeCirc &&
                                           currentLesson.questionRatio && currentLesson.questionRatio.length > 0;
                    let newQuestions = [];
                    if (useRatioForNew) {
                        const normalizedRatio = [...currentLesson.questionRatio, 0, 0, 0, 0, 0].slice(0, 6);
                        console.log(`Using getQuestionsByRatio for ${totalNew} new questions. Ratio: ${normalizedRatio}, Allowed: ${currentAllowedTypes}`);
                        newQuestions = getQuestionsByRatio(availableNewPools, normalizedRatio, totalNew, currentAllowedTypes);
                    } else {
                        console.log(`Using getRandomQuestionsFromEnabledTypes for ${totalNew} new questions. Allowed: ${currentAllowedTypes}`);
                        newQuestions = getRandomQuestionsFromEnabledTypes(availableNewPools, totalNew, currentAllowedTypes);
                    }
                    questionPool.push(...newQuestions.map(q => ({ ...q, origin: 'new' })));
                }

                // 2. Add Relearn Questions (Actual first, then Unlimited if applicable)
                // ... (The rest of your existing, previously corrected relearn and unlimited logic from step 2 onwards)
                let actualRelearnItemsChosenThisTurn = [];
                if (totalRelearn > 0 && useRelearn && !isHandwritingFocus) {
                    const actualRelearnCandidates = getRelearnQuestions(availableRelearnPools, totalRelearn);
                    actualRelearnItemsChosenThisTurn = actualRelearnCandidates.map(q => ({ ...q, origin: 'relearn', isActualRelearn: true }));
                    questionPool.push(...actualRelearnItemsChosenThisTurn);

                    if (actualRelearnItemsChosenThisTurn.length > 0) {
                        window.lessonStats.servedActualRelearn = true;
                    }
                    const numActualRelearnAdded = actualRelearnItemsChosenThisTurn.length;

                    if (numActualRelearnAdded < totalRelearn && currentLesson.allowUnlimitedPracticePool === true && effectivePracticeCirc) {
                        const neededFromUnlimited = totalRelearn - numActualRelearnAdded;
                        console.log(`Actual relearn items: ${numActualRelearnAdded}. Need ${neededFromUnlimited} more from unlimited pool.`);
                        let unlimitedPracticeCandidates = [];

                        if (currentAllowedTypes.includes('type1')) {
                            const practiceType1Pool = (allType1Data || type1Data).filter(q => {
                                if (!q || typeof q.code !== 'string') return false;
                                const isAlreadyInActualRelearnPool = relearnType1.some(r1q => r1q.word === q.word);
                                const isPickedAsActualThisTurn = actualRelearnItemsChosenThisTurn.some(ar => ar.isActualRelearn && ar.word === q.word);
                                return !isAlreadyInActualRelearnPool && !isPickedAsActualThisTurn && CodeParser.compare(q.code, currentLesson.praclimit || '');
                            });
                            unlimitedPracticeCandidates.push(...practiceType1Pool);
                        }
                        if (currentAllowedTypes.includes('type2')) {
                            const practiceType2Pool = type2Data.filter(q => {
                                if (!q || typeof q.code !== 'string' || !q.sentence || !q.blank) return false;
                                const isAlreadyInActualRelearnPool = relearnType2.some(r2q => r2q.sentence === q.sentence && JSON.stringify(r2q.blank) === JSON.stringify(q.blank));
                                const isPickedAsActualThisTurn = actualRelearnItemsChosenThisTurn.some(ar => ar.isActualRelearn && ar.sentence === q.sentence && JSON.stringify(ar.blank) === JSON.stringify(q.blank));
                                return !isAlreadyInActualRelearnPool && !isPickedAsActualThisTurn && CodeParser.compare(q.code, currentLesson.praclimit || '');
                            });
                            unlimitedPracticeCandidates.push(...practiceType2Pool);
                        }
                        unlimitedPracticeCandidates = shuffleArray(unlimitedPracticeCandidates);
                        const additionalUnlimitedQuestions = unlimitedPracticeCandidates.slice(0, neededFromUnlimited);
                        if (additionalUnlimitedQuestions.length > 0) {
                            console.log(`Adding ${additionalUnlimitedQuestions.length} questions from general pool for unlimited practice.`);
                            questionPool.push(...additionalUnlimitedQuestions.map(q => ({ ...q, origin: 'relearn', isActualRelearn: false })));
                        } else {
                            console.log("No additional suitable questions found in general pool for unlimited practice.");
                        }
                    }
                }


                // 3. Shuffle and Select Question
                questionPool = shuffleArray(questionPool);
                currentQuestion = questionPool.length > 0 ? questionPool[0] : null;

                // 4. Handle No Question Found Scenario
                if (!currentQuestion) {
                    let errorMsg = `No valid questions found for lesson ${currentCode} based on current settings. `;
                    if (isHandwritingFocus && (type6Data.length === 0 || !enabledQuestionTypes.includes('type6'))) {
                         errorMsg += "Handwriting circle, but Type 6 disabled or no Type 6 questions available. ";
                    } else if (isHandwritingFocus) {
                         errorMsg += "Handwriting circle, general issue finding Type 6 question. ";
                    }
                    else if (effectivePracticeCirc && !useRelearn) errorMsg += "Practice circle active but relearn pool disabled/empty. ";
                    else if (effectivePracticeCirc && useRelearn && questionPool.length === 0 && currentLesson.allowUnlimitedPracticePool !== true) {
                        errorMsg = `Practice Circle: All specific review items completed. No more items to review in this session.`;
                        if (questionsCompleted === 0) {
                            showFeedback(errorMsg, "warning");
                            setTimeout(() => { window.location.href = 'mainnightly.html'; }, 2000);
                            disableButtons(false);
                            return;
                        } else {
                            console.warn(errorMsg + " Ending lesson early.");
                            completeLesson();
                            return;
                        }
                    }
                    else if (questionPool.length === 0) {
                         errorMsg += `Pool empty. Allowed types: ${currentAllowedTypes.join(', ')}. `;
                    }

                    if (questionsCompleted === 0 && questionPool.length === 0) {
                         throw new Error(errorMsg + `Config: ${JSON.stringify(currentLesson)}`);
                    } else if (questionPool.length === 0) {
                        console.warn(errorMsg + "Ending lesson early.");
                        completeLesson();
                        return;
                    }
                }

                // 5. Display Question & Update Progress
                if (currentQuestion &&
                    effectivePracticeCirc &&
                    currentLesson.allowUnlimitedPracticePool === true &&
                    currentQuestion.origin === 'relearn' &&
                    currentQuestion.isActualRelearn === false &&
                    window.lessonStats.servedActualRelearn &&
                    !window.lessonStats.shownUnlimitedSwitchFeedback) {
                        showFeedback("All specific review items covered. Continuing with general practice.", "info");
                        window.lessonStats.shownUnlimitedSwitchFeedback = true;
                }

                displayQuestion(currentQuestion);
                questionsCompleted++;
                updateProgress();
                disableButtons(false);

                performance.mark("questionEnd");
                performance.measure("questionDuration", "questionStart", "questionEnd");
                const duration = performance.getEntriesByName("questionDuration").pop();
                console.log("Question generation took:", duration ? duration.duration.toFixed(2) : 'N/A', "ms");

            } catch (error) {
                console.error('Question generation error:', error);
                showError(`Question loading failed: ${error.message}. Redirecting...`);
                setTimeout(() => window.location.href = 'mainnightly.html', 3000);
            }
        }
        // --- END REVISED generateNextQuestion ---


        // Helper: Get questions distributed by ratio
        function getQuestionsByRatio(typePools, ratio, count, allowedTypes) {
            // Ensure pools match allowed types
            const availablePools = typePools.map((pool, index) =>
                allowedTypes.includes(`type${index + 1}`) ? pool : []
            );
            // Calculate total weight *only* from allowed types specified in the ratio array
            const relevantRatio = ratio.filter((_, index) => allowedTypes.includes(`type${index + 1}`));
            const totalWeight = relevantRatio.reduce((sum, w) => sum + w, 0);

            if (totalWeight === 0 || count === 0) {
                console.warn("getQuestionsByRatio: Zero total weight or count is zero. Returning empty.", { totalWeight, count });
                return [];
            }

            let typeCounts = new Array(typePools.length).fill(0);
            let remainingCount = count;
            let idealCounts = [];

            // 1. Calculate ideal counts (float) and initial floored counts
            availablePools.forEach((pool, index) => {
                if (allowedTypes.includes(`type${index + 1}`) && ratio[index] > 0 && pool.length > 0) {
                    const ideal = (ratio[index] / totalWeight) * count;
                    idealCounts[index] = { index: index, ideal: ideal, fraction: ideal - Math.floor(ideal) };
                    const flooredCount = Math.min(Math.floor(ideal), pool.length); // Can't take more than available
                    typeCounts[index] = flooredCount;
                    remainingCount -= flooredCount;
                } else {
                     idealCounts[index] = { index: index, ideal: 0, fraction: 0 }; // Store 0 if not allowed/no ratio/empty pool
                     typeCounts[index] = 0;
                }
            });

            console.log("getQuestionsByRatio - Initial Counts:", typeCounts, "Remaining:", remainingCount);

            // 2. Distribute remaining count based on largest fractional parts
            idealCounts.sort((a, b) => b.fraction - a.fraction); // Sort by largest fraction first

            for (const item of idealCounts) {
                const index = item.index;
                if (remainingCount <= 0) break; // Stop if we've distributed enough

                // Check if we can add one more to this type (already took floor, now add 1 if needed)
                // and ensure the pool has enough questions
                 const currentPool = availablePools[index];
                if (typeCounts[index] < currentPool.length) { // Check if pool has more questions available
                    typeCounts[index]++;
                    remainingCount--;
                    console.log(`getQuestionsByRatio - Distributed +1 to type ${index + 1}. Remaining: ${remainingCount}`);
                }
            }

            // Handle any potential over-distribution due to rounding edge cases (should be rare now)
            let currentTotal = typeCounts.reduce((a, b) => a + b, 0);
            while (currentTotal > count) {
                 // Find a type with count > 0 to decrement, maybe prioritize lowest fraction?
                 let decremented = false;
                 for (const item of idealCounts.reverse()) { // Try removing from smallest fractions first
                     const index = item.index;
                     if (typeCounts[index] > 0) {
                         typeCounts[index]--;
                         currentTotal--;
                         console.warn(`getQuestionsByRatio - Over-distribution detected. Decremented type ${index + 1}.`);
                         decremented = true;
                         break;
                     }
                 }
                  if (!decremented) break; // Safety break
            }


            console.log("getQuestionsByRatio - Final Counts:", typeCounts);

            // 3. Select questions based on final counts
            const questions = [];
            availablePools.forEach((pool, index) => {
                if (typeCounts[index] > 0 && pool.length > 0) {
                    // Apply practice limit filter here again as a safeguard
                    const filteredPool = pool.filter(q => CodeParser.compare(q.code, currentLesson.praclimit || ''));
                     const countToTake = Math.min(typeCounts[index], filteredPool.length); // Take calculated count or max available
                    questions.push(...shuffleArray(filteredPool).slice(0, countToTake));
                     if (countToTake < typeCounts[index]) {
                         console.warn(`getQuestionsByRatio - Could only get ${countToTake}/${typeCounts[index]} for type ${index+1} after filtering.`);
                     }
                }
            });

             console.log(`getQuestionsByRatio - Selected ${questions.length} questions initially.`);

            // Shuffle the final list and ensure it doesn't exceed the original required count
            // This slice handles cases where pools might have had fewer items than calculated counts needed.
            return shuffleArray(questions).slice(0, count);
        }

        // Helper: Get random questions from enabled types
        function getRandomQuestionsFromEnabledTypes(typePools, count, allowedTypes) {
             if (count === 0) return [];

            const availableQuestions = typePools.flatMap((pool, index) =>
                allowedTypes.includes(`type${index + 1}`) ?
                pool.filter(q => CodeParser.compare(q.code, currentLesson.praclimit || '')) :
                []
            );

            if (availableQuestions.length === 0) {
                console.warn('No questions available from any enabled/allowed type pools.');
                return [];
            }

            // Shuffle all available questions and take the required count
            return shuffleArray(availableQuestions).slice(0, count);
        }


        // Helper: Get relearn questions balanced between types
        function getRelearnQuestions(relearnPools, count) {
             if (count === 0) return [];

            // Flatten all available relearn questions
            const allRelearn = relearnPools.flat();

            if (allRelearn.length === 0) {
                console.warn("Relearn requested, but relearn pools are empty.");
                return [];
            }

            // Shuffle and take the required count
            return shuffleArray(allRelearn).slice(0, count);
        }


        // Helper: Weighted random selection (currently not used in revised logic, keep if needed later)
        function weightedRandom(options) {
            const total = options.reduce((sum, {weight}) => sum + weight, 0);
            if (total === 0) return options.length > 0 ? options[Math.floor(Math.random() * options.length)].value : null; // Fallback if weights are zero
            const random = Math.random() * total;
            let current = 0;

            for (const {weight, value} of options) {
                current += weight;
                if (random <= current) return value;
            }
            // Fallback in case of floating point issues
            return options.length > 0 ? options[options.length - 1].value : null;
        }

        // Get a random question from a pool (used as fallback, main logic now shuffles and takes first)
        function getRandomQuestion(pool) {
            if (!pool || pool.length === 0) return null;
            return pool[Math.floor(Math.random() * pool.length)];
        }

        // --- REVISED displayQuestion to use question.origin ---
        function displayQuestion(question) {
            const activity = document.getElementById('activity');
            activity.innerHTML = ''; // Clear previous content
            const originIndicator = document.getElementById('questionOrigin');

            // Reset and update origin indicator based on the passed question object
            originIndicator.classList.remove('visible', 'relearn', 'new');
            if (question.origin) { // Check if the origin tag exists
                originIndicator.textContent = question.origin === 'relearn' ? 'Relearn Pool' : 'New Words';
                originIndicator.className = `question-origin ${question.origin}`; // Apply 'relearn' or 'new' class

                // Animate in after short delay
                setTimeout(() => {
                    originIndicator.classList.add('visible');
                }, 300);
            }

            try {
                // Determine question type based on properties (prioritize more specific types)
                if (question.kanji) { // Type 6
                    activity.innerHTML = generateType6Question(question);
                    setTimeout(initCanvas, 50); // Initialize canvas after HTML is rendered
                } else if (question.validCombinations) { // Type 5
                    activity.innerHTML = generateType5Question(question);
                    initType5DragDrop(); // Initialize drag-drop
                } else if (question.audio) { // Type 3 or 4
                     // Append audio player first
                     const audioContainer = document.createElement('div');
                     audioContainer.className = 'audio-player-container';
                     audioContainer.innerHTML = `
                         <button onclick="playAudio('${question.audio}')">▶ Play Audio</button>
                         <audio id="currentAudioPlayer" src="${dynamicBasePath}audiofiles/${question.audio}"></audio>
                     `;
                     activity.appendChild(audioContainer);

                    if (question.blocks) { // Type 4
                        activity.innerHTML += generateType4Question(question);
                    } else if (question.answers?.text) { // Type 3
                        activity.innerHTML += generateType3Question(question);
                        // Store correct answers temporarily if needed for validation (e.g., for text input mode)
                        setTimeout(() => {
                             const type3Container = activity.querySelector('.type3-question-container');
                             if (type3Container) {
                                 // Assuming the first answer in 'text' is the primary correct one for MCQs
                                 type3Container.dataset.correctAnswers = JSON.stringify(question.answers.text || []);
                             }
                        }, 0);
                    } else {
                         throw new Error(`Audio question missing identifiable type (blocks or answers.text). Code: ${question.code}`);
                    }
                 } else if (question.word && question.translation) { // Type 1
                    activity.innerHTML = generateType1Question(question);
                } else if (question.blank && question.sentence) { // Type 2
                    activity.innerHTML = generateType2Question(question);
                } else {
                    console.error("Unknown question structure:", question);
                    throw new Error(`Invalid or unknown question structure for code ${question.code || 'N/A'}`);
                }
            } catch (error) {
                console.error('Question display error:', error);
                showError(`Failed to display question: ${error.message}`);
                // Attempt to generate the next question after a delay to avoid getting stuck
                setTimeout(() => generateNextQuestion(), 1500);
            }
        }

        function playAudio(path) {
            const audio = new Audio(`${dynamicBasePath}audiofiles/${path}`);
            audio.play();
        }
        // --- END REVISED displayQuestion ---


        // Shuffle array utility
        function shuffleArray(array) {
            if (!array) return [];
            let currentIndex = array.length, randomIndex;
            while (currentIndex !== 0) {
                randomIndex = Math.floor(Math.random() * currentIndex);
                currentIndex--;
                [array[currentIndex], array[randomIndex]] = [array[randomIndex], array[currentIndex]];
            }
            return array;
        }

        function generateType1Question(question) {
            if (!question || typeof question.word !== 'string' || typeof question.translation !== 'string') {
                 console.error("Invalid input to generateType1Question:", question);
                 return `<div class="error">Error: Invalid vocabulary data.</div>`;
            }

            const shouldSwap = currentLesson?.swapType1Direction === true && Math.random() < 0.5;
            let displayPrompt = '';
            let correctAnswerForButton = '';
            const originalWordForFiltering = question.word; // The word of the current question

            if (shouldSwap) {
                displayPrompt = `Which word means "${question.word}"?`;
                correctAnswerForButton = question.translation;
            } else {
                displayPrompt = `Which word means "${question.translation}"?`;
                correctAnswerForButton = question.word;
            }
             if (typeof correctAnswerForButton !== 'string') correctAnswerForButton = 'ErrorFallback';


            const relearnDistractorCandidates = relearnType1.filter(q => {
                if (!q || typeof q.word !== 'string') return false;
                return q.word !== originalWordForFiltering;
            });

            // <<< MODIFIED: Use allType1Data for a broader selection of new word distractors >>>
            const newWordDistractorCandidates = allType1Data.filter(q => {
                if (!q || typeof q.word !== 'string') return false;
                if (q.word === originalWordForFiltering) return false; // Exclude the correct answer's original word

                // Optional: If in a practice circle with praclimit, respect it for distractors from allType1Data.
                // This ensures distractors are not from "future" content relative to the practice circle's scope.
                if (currentLesson.practicecirc && currentLesson.praclimit) {
                    return CodeParser.compare(q.code, currentLesson.praclimit);
                }
                return true;
            });

            const totalOptions = [2, 3, 4][Math.floor(Math.random() * 3)];
            let numWrongNeeded = totalOptions - 1;
            if (numWrongNeeded <= 0) numWrongNeeded = 1;

            const finalWrongOptions = [];
            const usedDistractorOriginalWords = new Set(); // Track original words to ensure conceptual uniqueness

            const addUniqueDistractor = (candidate) => {
                if (!candidate || typeof candidate.word !== 'string' || (shouldSwap && typeof candidate.translation !== 'string')) {
                    return false;
                }
                // The "original word" of the candidate is candidate.word, regardless of swap.
                // The "display word" depends on shouldSwap.
                if (finalWrongOptions.length < numWrongNeeded && !usedDistractorOriginalWords.has(candidate.word)) {
                    finalWrongOptions.push(candidate);
                    usedDistractorOriginalWords.add(candidate.word); // Add the candidate's original word to the set
                    return true;
                }
                return false;
            };

            const shuffledRelearn = shuffleArray([...relearnDistractorCandidates]);
            for (const candidate of shuffledRelearn) {
                addUniqueDistractor(candidate);
                if (finalWrongOptions.length >= numWrongNeeded) break;
            }

            if (finalWrongOptions.length < numWrongNeeded) {
                const shuffledNewWords = shuffleArray([...newWordDistractorCandidates]);
                for (const candidate of shuffledNewWords) {
                    addUniqueDistractor(candidate);
                    if (finalWrongOptions.length >= numWrongNeeded) break;
                }
            }

            // Ensure displayed texts are unique, including the correct answer
            const displayedOptionTexts = new Set();
            if (typeof correctAnswerForButton === 'string') {
                displayedOptionTexts.add(correctAnswerForButton);
            }
            const uniqueFinalWrongOptions = [];
            for (const opt of finalWrongOptions) {
                const text = (shouldSwap && typeof opt.translation === 'string') ? opt.translation : opt.word;
                if (typeof text === 'string' && !displayedOptionTexts.has(text)) {
                    uniqueFinalWrongOptions.push(opt);
                    displayedOptionTexts.add(text);
                }
            }
            // If we removed too many due to display text collision, numWrongNeeded might not be met.
            // Update finalWrongOptions with the unique ones.
            const currentFinalWrongOptions = [...uniqueFinalWrongOptions];


            let dummyCounter = 1;
            while ((currentFinalWrongOptions.length + 1) < totalOptions || currentFinalWrongOptions.length < numWrongNeeded) {
                 let dummyWord = `Opción ${dummyCounter++}`; // Assuming Spanish based on example data
                 while(displayedOptionTexts.has(dummyWord)) { // Check against already displayed texts
                     dummyWord = `Opción ${dummyCounter++}`;
                 }
                 currentFinalWrongOptions.push({ word: dummyWord, translation: "???", isDummy: true });
                 displayedOptionTexts.add(dummyWord);
                 if (currentFinalWrongOptions.length >= numWrongNeeded && (currentFinalWrongOptions.length + 1) >= totalOptions) break;
            }


            const correctOptionForDisplay = { text: correctAnswerForButton };
            const wrongOptionsForDisplay = currentFinalWrongOptions.map(o => {
                 let textToShow = 'InvalidOption';
                 if (o.isDummy) {
                     textToShow = o.word;
                 } else if (shouldSwap) {
                     textToShow = (typeof o.translation === 'string') ? o.translation : o.word;
                 } else {
                      textToShow = (typeof o.word === 'string') ? o.word : o.translation;
                 }
                 if (typeof textToShow !== 'string') textToShow = 'ErrorOption';
                 return { text: textToShow };
            });

            const finalOptionsSet = shuffleArray([correctOptionForDisplay, ...wrongOptionsForDisplay]);

            return `
                <div class="question">${displayPrompt}</div>
                <div class="options">
                    ${finalOptionsSet.map(o => {
                        const wordText = typeof o.text === 'string' ? o.text : 'ButtonError';
                        const escapedWord = wordText.replace(/'/g, "\\'");
                        const escapedCorrect = correctAnswerForButton.replace(/'/g, "\\'");
                        return `
                            <button onclick="selectAnswer('${escapedWord}', '${escapedCorrect}')">
                                ${wordText}
                            </button>
                        `;
                    }).join('')}
                </div>
            `;
        }

        // Type 2
        function generateType2Question(question) {
             // Store correct/possible answers on a container for later validation
             const possible = [...(Array.isArray(question.blank) ? question.blank : [question.blank]), ...(question.possibleAnswers || [])];
            return `
                <div id="type2Container" data-possible-answers='${JSON.stringify(possible)}'>
                    <div class="question">${question.sentence}</div>
                    <p>${question.translation || ''}</p>
                    <input type="text" id="grammarAnswer" placeholder="Your answer" autocomplete="off">
                    <button onclick="checkGrammarAnswer()">Submit Answer</button>
                </div>
            `;
        }

        // Type 3
        function generateType3Question(question) {
            const correctAnswer = question.answers.text[0]; // Assume first is primary for MC
            let candidatePool = type3Data
                .filter(q => q.code === question.code && q !== question && q.answers?.selection)
                .flatMap(q => q.answers.selection); // Use 'selection' for distractors if available

            // Fallback: use other answers.text if selection is empty/missing
            if (candidatePool.length === 0) {
                 candidatePool = type3Data
                     .filter(q => q.code !== question.code && q.answers?.text) // Look broader if needed
                     .flatMap(q => q.answers.text);
            }

            candidatePool = Array.from(new Set(candidatePool)).filter(a => a !== correctAnswer); // Unique & not correct

            const totalOptions = [2, 3, 4][Math.floor(Math.random() * 3)];
            const numWrong = totalOptions - 1;
            const wrongOptions = shuffleArray(candidatePool).slice(0, numWrong);
            let options = shuffleArray([correctAnswer, ...wrongOptions]);

            // Ensure minimum options
            while(options.length < 2) options.push(`Option ${options.length + 1}`);

            return `
                <div class="type3-question-container">
                    <div class="question">Which word did you hear?</div>
                    <div class="type3-options" id="type3Options">
                        ${options.map(opt => `
                            <button onclick="handleType3Answer('${opt.replace(/'/g, "\\'")}')">
                                ${opt}
                            </button>
                        `).join('')}
                    </div>
                    <div id="type3TextContainer" style="display: none; text-align: center; margin-top: 10px;">
                        <input type="text" id="type3TextInput" placeholder="Type what you heard" style="width: 300px; padding: 12px; font-size: 1.1rem; text-align: center;" autocomplete="off">
                        <button id="type3Submit" onclick="handleType3TextSubmit()">Submit</button>
                    </div>
                    <div class="input-mode" id="type3InputContainer" style="text-align: center; margin-top: 10px;">
                        <label for="type3InputMode">Input:</label>
                        <select id="type3InputMode" onchange="updateType3InputMode()">
                            <option value="selection">Multiple Choice</option>
                            <option value="text">Type Answer</option>
                        </select>
                    </div>
                </div>
            `;
        }

        // Type 4
        function getType4Distractors(currentCode, currentBlocks) { // currentCode is now less relevant here
            console.log(`--- getType4Distractors Start (Broad Search for Current: ${currentCode}) ---`);
            console.log("Correct Blocks to Exclude:", currentBlocks);

            // --- Get ALL blocks from ALL Type 4 questions ---
            const allAvailableBlocks = type4Data.flatMap(q => {
                // Ensure question has blocks and it's an array
                if (q && Array.isArray(q.blocks)) {
                    return q.blocks;
                }
                return []; // Return empty array if blocks are missing/invalid
            });
            console.log(`Total blocks found across all Type 4 questions: ${allAvailableBlocks.length}`);

            // --- Create a unique set of potential distractors ---
            // Filter out blocks already present in the correct answer for the *current* question
            // Also ensure block is a non-empty string
            const uniqueDistractors = Array.from(new Set(allAvailableBlocks))
                                          .filter(block => typeof block === 'string' && block.trim() !== '' && !currentBlocks.includes(block));
            console.log(`Found ${uniqueDistractors.length} unique blocks (excluding correct blocks) available as distractors.`);
            // console.log(`Unique Distractors Available:`, uniqueDistractors); // Optional: Log the actual blocks

            // --- Determine Number of Distractors (0 to 4) ---
            const maxPossibleDistractors = Math.min(uniqueDistractors.length, 4); // Cap at 4 or available unique distractors
            const numDistractorsToAdd = maxPossibleDistractors > 0 ? Math.floor(Math.random() * (maxPossibleDistractors + 1)) : 0;

            console.log(`Max possible distractors to add: ${maxPossibleDistractors}`);
            console.log(`Calculated numDistractorsToAdd: ${numDistractorsToAdd}`);

            // --- Select and return the distractors ---
            const selectedDistractors = shuffleArray(uniqueDistractors).slice(0, numDistractorsToAdd);
            console.log("Selected Distractors to Add:", selectedDistractors);
            console.log(`--- getType4Distractors End ---`);
            return selectedDistractors;
        }

        function generateType4Question(question) {
            console.log(`--- generateType4Question Start (Code: ${question.code}) ---`);
            console.log("Correct Blocks for Question:", question.blocks);

            // Get a variable number (0-4) of incorrect blocks
            const distractors = getType4Distractors(question.code, question.blocks);
            console.log("Distractors received from getType4Distractors:", distractors); // Log received distractors

            // Combine with original blocks and shuffle
            const combined = [...question.blocks, ...distractors];
            console.log("Combined Blocks (Correct + Distractors):", combined);
            const allBlocks = shuffleArray(combined);
            console.log("Shuffled allBlocks for Tray:", allBlocks);

            // Store correct sequence and possible answers for validation
            const correctSequence = question.blocks.join(' ');
            // Ensure possibleAnswers exists or provide empty array
            const possibleAnswersList = [correctSequence, ...(question.possibleAnswers || [])];
            const possibleAnswers = JSON.stringify(possibleAnswersList);


            return `
                <div id="type4Container" data-possible-answers='${possibleAnswers.replace(/'/g, "'")}'>
                    <div class="question">Build the sentence you heard:</div>
                    <div class="input-mode-selector">
                        <label for="inputMode">Input:</label>
                        <select id="inputMode" onchange="toggleType4InputMode()">
                            <option value="blocks">Word Blocks</option>
                            <option value="text">Type Answer</option>
                        </select>
                    </div>
                    <!-- Blocks Mode -->
                    <div id="blocksMode">
                        <div class="blocks-tray" id="initialTray">
                            ${allBlocks.map(block => {
                                // Ensure block is a string before rendering
                                const blockText = (typeof block === 'string') ? block : 'InvalidBlock';
                                return `<div class="word-block" onclick="moveBlock(this)">${blockText}</div>`;
                            }).join('')}
                        </div>
                        <div class="sentence-builder" id="answerTray"></div>
                    </div>
                    <!-- Text Mode -->
                    <div id="textMode" style="display: none;">
                        <input type="text" id="type4TextInput" placeholder="Type the sentence here" autocomplete="off">
                    </div>
                    <button onclick="checkType4Answer()">Submit</button>
                </div>
            `;
        }

        // Type 5
        function getType5Distractors(currentQuestion, maxDesiredDistractors = 4) { // Renamed param for clarity
            const functionName = "getType5Distractors";
            console.log(`--- ${functionName} Start (Current Q Code: ${currentQuestion.code}) ---`);
            console.log(`${functionName}: Max *desired* distractors: ${maxDesiredDistractors}`);

            if (!currentQuestion || !Array.isArray(currentQuestion.validCombinations) || currentQuestion.validCombinations.length === 0) {
                console.error(`${functionName}: Cannot get distractors - Invalid or missing 'validCombinations'.`);
                return [];
            }

            // --- 1. Identify all unique valid words for the CURRENT question (Normalized) ---
            const allValidWordsForCurrentQ = Array.from(new Set(
                currentQuestion.validCombinations.flat().map(normalizeJapanese)
            ));
            console.log(`${functionName}: Normalized valid words for current question:`, allValidWordsForCurrentQ);

            // --- 2. Build a POOL of ALL potential unique distractors (Internal + External, Normalized) ---
            const potentialDistractorPool = new Set();

            // 2a. Add Internal Distractors to Pool
            if (Array.isArray(currentQuestion.blocks)) {
                const potentialInternal = currentQuestion.blocks.map(normalizeJapanese);
                for (const block of potentialInternal) {
                    if (block && !allValidWordsForCurrentQ.includes(block)) {
                        potentialDistractorPool.add(block);
                    }
                }
                console.log(`${functionName}: Pool size after internal check: ${potentialDistractorPool.size}`);
            }

            // 2b. Add External Distractors to Pool
            const otherQuestions = type5Data.filter(q =>
                q && q !== currentQuestion &&
                Array.isArray(q.validCombinations) && q.validCombinations.length > 0
            );

            if (otherQuestions.length > 0) {
                const externalWords = Array.from(new Set(
                    otherQuestions.flatMap(q => q.validCombinations.flat())
                )).map(normalizeJapanese);

                for (const block of externalWords) {
                    if (block && !allValidWordsForCurrentQ.includes(block)) {
                        potentialDistractorPool.add(block); // Set handles uniqueness
                    }
                }
                console.log(`${functionName}: Pool size after external check: ${potentialDistractorPool.size}`);
            }

            const availableDistractors = Array.from(potentialDistractorPool);
            console.log(`${functionName}: Total unique available distractors in pool: ${availableDistractors.length}`);
            // console.log(`${functionName}: Available Pool Contents:`, availableDistractors); // Optional: Log pool

            // --- 3. Determine the RANDOM number of distractors to actually add ---
            // The number cannot exceed the desired maximum OR the number actually available.
            const maxPossibleToAdd = Math.min(availableDistractors.length, maxDesiredDistractors);
            const numDistractorsToAdd = Math.floor(Math.random() * (maxPossibleToAdd + 1)); // Random integer between 0 and maxPossibleToAdd (inclusive)

            console.log(`${functionName}: Max *possible* to add (based on pool & desired max): ${maxPossibleToAdd}`);
            console.log(`${functionName}: Randomly chosen number of distractors to add: ${numDistractorsToAdd}`);

            // --- 4. Select the distractors ---
            const selectedDistractors = shuffleArray(availableDistractors).slice(0, numDistractorsToAdd);

            console.log(`${functionName}: Final selected distractors (${selectedDistractors.length}):`, selectedDistractors);
            console.log(`--- ${functionName} End ---`);
            return selectedDistractors; // Return the randomly selected subset
        }

        function generateType5Question(question) {
            // --- Validate Input ---
            if (!question || !Array.isArray(question.validCombinations) || question.validCombinations.length === 0 || !question.validCombinations[0] || !Array.isArray(question.validCombinations[0])) {
                 console.error("Invalid data for generateType5Question:", question);
                 return `<div class="error">Error: Invalid Type 5 data structure (missing/invalid validCombinations).</div>`;
            }

            // Determine Layout
            const TYPE5_SPLIT_THRESHOLD = 3;

            // --- Prepare Blocks for Tray ---
            // 1. Get the 'correct' set (use the first valid combination as the primary answer set for the tray)
            const primaryCorrectSet = question.validCombinations[0].map(normalizeJapanese); // Normalize the correct set too

            // Get distractors (internal + external), decide max number here (e.g., 4)
            const MAX_DISTRACTORS = 4; // Set maximum desired distractors
            const distractors = getType5Distractors(question, MAX_DISTRACTORS).map(normalizeJapanese); // Pass question object, get normalized distractors

            // Combine for the tray: Primary correct set + distractors. Use Set to avoid duplicates if a distractor somehow matches a primary word.
            const combinedBlocksSet = new Set([...primaryCorrectSet, ...distractors]);
            const allBlocksForTray = shuffleArray(Array.from(combinedBlocksSet));

            console.log("Normalized Primary Correct Set:", primaryCorrectSet);
            console.log("Selected Distractors:", distractors);
            console.log("Final Unique Blocks for Tray:", allBlocksForTray);

            // --- Store data needed for validation ---
            const validCombinationsJSON = JSON.stringify(question.validCombinations);


            // --- Generate HTML parts (inputModeSelectorsHtml, blocksModeHtml, etc. as before) ---
            const numBlanks = question.validCombinations[0].length;
            const sentenceHtml = insertNumberedBlanks(question.sentence, numBlanks);

            const inputModeSelectorsHtml = `
                <div class="input-mode-selector">
                    <label for="type5InputMode">Input:</label>
                    <select id="type5InputMode" onchange="toggleType5InputMode()">
                        <option value="blocks">Word Blocks</option>
                        <option value="text">Type Answer</option>
                    </select>
                </div>`;

            // Use the final allBlocksForTray for rendering
            const blocksModeHtml = `
                <div id="type5BlocksMode">
                    <div class="blocks-tray" id="type5InitialTray">
                        ${allBlocksForTray.map(block => `<div class="word-block draggable" draggable="true">${block}</div>`).join('')}
                    </div>
                </div>`;

            const textModeHtml = `
                <div id="type5TextMode" style="display: none;">
                    ${generateNumberedTextInputs(numBlanks)}
                </div>`;

            const submitButtonHtml = `<button onclick="validateType5Answer()">Submit</button>`;


            // --- Assemble Layout (Standard and Split) ---
            let contentHtml = '';
             const useSplitLayout = numBlanks > 3; // Keep threshold or adjust

            if (useSplitLayout) {
                // ... (Assemble split layout using the updated variables) ...
                 contentHtml = `
                    <div class="type5-split-layout">
                        <div class="type5-left-column">
                            <div class="question"> ${sentenceHtml} </div>
                            <p><em>Translation: ${question.translation || ''}</em></p>
                        </div>
                        <div class="type5-right-column">
                            <div class="type5-instruction">Complete the text.</div>
                             ${inputModeSelectorsHtml}
                             ${blocksModeHtml}
                             ${textModeHtml}
                             ${submitButtonHtml}
                        </div>
                    </div>
                `;
            } else {
                 // ... (Assemble standard layout using the updated variables) ...
                  contentHtml = `
                    <div class="question">
                        <div class="type5-instruction">Complete the sentence.</div>
                        ${sentenceHtml}
                    </div>
                    <p>${question.translation || ''}</p>
                    ${inputModeSelectorsHtml}
                    ${blocksModeHtml}
                    ${textModeHtml}
                    ${submitButtonHtml}
                `;
            }


            // --- Return container with generated content ---
            return `
                <div id="type5Container" data-valid-combinations='${validCombinationsJSON.replace(/'/g, "'")}'>
                   ${contentHtml}
                </div>
            `;
        }

        // Update insertNumberedBlanks and generateNumberedTextInputs slightly if needed
        // (Ensure they correctly use numBlanks parameter)
        function insertNumberedBlanks(sentence, numBlanks) { // Added numBlanks parameter
            let blankCount = 0;
            const parts = sentence.split('[__]');
            // Only add blanks up to the expected number based on numBlanks
            return parts.map((part, index) => {
                if (index === parts.length - 1 || blankCount >= numBlanks) return part;
                blankCount++;
                return `${part}<div class="blank-container">
                            <span class="blank-number">[${blankCount}]</span>
                            <div class="type5-blank type5-answer-slot" id="blank${index}"
                                 ondrop="drop(event, ${index})" ondragover="allowDrop(event)"></div>
                        </div>`;
            }).join('');
        }

        function generateNumberedTextInputs(numBlanks) { // Added numBlanks parameter
             let inputsHtml = '';
             for (let index = 0; index < numBlanks; index++) {
                 inputsHtml += `
                    <div class="text-input-group">
                        <span class="input-number">[${index + 1}]</span>
                        <input type="text"
                               class="type5-text-input"
                               data-blank-index="${index}"
                               placeholder="Answer for blank ${index + 1}"
                               autocomplete="off">
                    </div>`;
             }
             return inputsHtml;
        }

        // Type 6
        function generateType6Question(question) {
            return `
                <div class="kanji-container" data-kanji="${question.kanji}">
                    <div class="kanji-prompt">Write this character: ${question.kanji}</div>
                    <div class="writing-area">
                        <canvas id="kanjiCanvas"></canvas>
                        <div class="grid-overlay"></div>
                    </div>
                    <div class="ocr-settings" style="display: none;"> <!-- Hide OCR toggle for now -->
                        <label>
                            <input type="checkbox" id="ocrToggle" ${enableOCR ? 'checked' : ''}>
                            Enable OCR Validation
                        </label>
                    </div>
                    <div class="kanji-controls">
                        <button onclick="resetCanvas()">↻ Reset</button>
                        <button onclick="validateKanji()">✓ Submit</button>
                    </div>
                </div>
            `;
        }

        // --- End Type Generation Functions ---


        // --- Input Mode Toggles & UI Helpers ---

        function updateType3InputMode() {
            const mode = document.getElementById('type3InputMode').value;
            const optionsContainer = document.getElementById('type3Options');
            const textContainer = document.getElementById('type3TextContainer');
            if (optionsContainer) optionsContainer.style.display = mode === 'selection' ? 'flex' : 'none';
            if (textContainer) textContainer.style.display = mode === 'text' ? 'block' : 'none';
        }

         function toggleType4InputMode() {
            const mode = document.getElementById('inputMode').value;
            const blocksMode = document.getElementById('blocksMode');
            const textMode = document.getElementById('textMode');
            if (blocksMode) blocksMode.style.display = mode === 'blocks' ? 'block' : 'none';
            if (textMode) textMode.style.display = mode === 'text' ? 'block' : 'none';
            // Optionally reset block positions when switching to blocks mode
            if (mode === 'blocks') resetBlockInterface();
        }

         function resetBlockInterface() {
            const initialTray = document.getElementById('initialTray');
            const answerTray = document.getElementById('answerTray');
            const blocksInAnswer = Array.from(answerTray.children);

            // Move blocks back from answer tray to initial tray
            blocksInAnswer.forEach(block => {
                block.onclick = () => moveBlock(block); // Ensure onclick is correct
                initialTray.appendChild(block);
            });

            // Shuffle blocks in initial tray
            const blocksToShuffle = Array.from(initialTray.children);
            shuffleArray(blocksToShuffle).forEach(block => initialTray.appendChild(block)); // Re-append in shuffled order
        }

        function moveBlock(block) {
             const initialTray = document.getElementById('initialTray');
             const answerTray = document.getElementById('answerTray');
             const targetTray = block.parentElement.id === 'answerTray' ? initialTray : answerTray;
             targetTray.appendChild(block); // Move the block element
        }

        function toggleType5InputMode() {
            const mode = document.getElementById('type5InputMode').value;
            const blocksMode = document.getElementById('type5BlocksMode');
            const textMode = document.getElementById('type5TextMode');
            if (blocksMode) blocksMode.style.display = mode === 'blocks' ? 'block' : 'none';
            if (textMode) textMode.style.display = mode === 'text' ? 'block' : 'none';

            if (mode === 'blocks') {
                 // Reset drag and drop state if needed
                 resetType5Blocks();
                 initType5DragDrop();
            }
        }

        function resetType5Blocks() {
            const initialTray = document.getElementById('type5InitialTray');
            document.querySelectorAll('.type5-blank').forEach(blank => {
                 const droppedBlock = blank.querySelector('.dropped-block');
                 if (droppedBlock) {
                      // Recreate the draggable block in the initial tray
                      const originalText = droppedBlock.textContent;
                      const newDraggable = document.createElement('div');
                      newDraggable.className = 'word-block draggable';
                      newDraggable.draggable = true;
                      newDraggable.textContent = originalText;
                      initialTray.appendChild(newDraggable);
                      droppedBlock.remove(); // Remove from blank
                 }
            });
             // Shuffle initial tray
             const blocksToShuffle = Array.from(initialTray.children);
             shuffleArray(blocksToShuffle).forEach(block => initialTray.appendChild(block));
        }
        // --- End Input Mode Toggles ---


        // --- Answer Checking Logic ---

        // Type 1 Answer
        function selectAnswer(selected, correct) {
            if (window.isAnswered) return;
            window.isAnswered = true;
            disableButtons(true);

            const isCorrect = selected === correct;
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");
            handleAnswerResult(currentQuestion, isCorrect); // Handle relearn logic

            setTimeout(generateNextQuestion, 1500);
        }

        // Type 2 Answer
        function checkGrammarAnswer() {
            if (window.isAnswered) return;
            window.isAnswered = true;
            disableButtons(true);

            const userInput = document.getElementById('grammarAnswer').value.trim();
            const normalizedUser = normalizeJapanese(userInput);

            const container = document.getElementById('type2Container');
            const possibleAnswers = JSON.parse(container.dataset.possibleAnswers || '[]');
            const normalizedPossible = possibleAnswers.map(normalizeJapanese);

            const isCorrect = normalizedPossible.includes(normalizedUser);
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");
            handleAnswerResult(currentQuestion, isCorrect);

            setTimeout(generateNextQuestion, 1500);
        }

        // Type 3 Answer (Multiple Choice)
        function handleType3Answer(selected) {
            if (window.isAnswered) return;
            window.isAnswered = true;
            disableButtons(true);

            const container = document.querySelector('.type3-question-container');
            const validAnswers = JSON.parse(container.dataset.correctAnswers || '[]'); // Get from container
            const normalizedSelected = normalizeJapanese(selected);
            const normalizedAnswers = validAnswers.map(normalizeJapanese);

            const isCorrect = normalizedAnswers.includes(normalizedSelected);
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");
            // Assuming Type 3 doesn't use standard relearn pool (audio focus)
            // handleAnswerResult(currentQuestion, isCorrect);

            setTimeout(generateNextQuestion, 1500);
        }

        // Type 3 Answer (Text Input)
        function handleType3TextSubmit() {
            if (window.isAnswered) return;
            window.isAnswered = true;
            disableButtons(true);

            const userAnswer = normalizeJapanese(document.getElementById('type3TextInput').value);
            const container = document.querySelector('.type3-question-container');
            const validAnswers = JSON.parse(container.dataset.correctAnswers || '[]');
            const normalizedAnswers = validAnswers.map(normalizeJapanese);

            const isCorrect = normalizedAnswers.includes(userAnswer);
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");
            // handleAnswerResult(currentQuestion, isCorrect);

            setTimeout(generateNextQuestion, 1500);
        }

        // Type 4 Answer
        function checkType4Answer() {
            if (window.isAnswered) return;
            window.isAnswered = true;
            disableButtons(true);

            const mode = document.getElementById('inputMode').value;
            let userAnswer = '';

            if (mode === 'blocks') {
                userAnswer = Array.from(document.querySelectorAll('#answerTray .word-block'))
                                .map(block => block.textContent.trim())
                                .join(' ');
            } else {
                userAnswer = document.getElementById('type4TextInput').value.trim();
            }

            const normalizedUser = normalizeJapanese(userAnswer.replace(/\s+/g, '')); // Normalize without spaces

            const container = document.getElementById('type4Container');
            const possibleAnswers = JSON.parse(container.dataset.possibleAnswers || '[]');
            const normalizedPossible = possibleAnswers.map(ans => normalizeJapanese(ans.replace(/\s+/g, '')));

            const isCorrect = normalizedPossible.includes(normalizedUser);
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");
            // handleAnswerResult(currentQuestion, isCorrect); // Type 4 usually doesn't use word/grammar relearn

            setTimeout(generateNextQuestion, 1500);
        }

        // Type 5 Answer
        function validateType5Answer() {
            if (window.isAnswered) return;
            window.isAnswered = true;
            disableButtons(true);

            const mode = document.getElementById('type5InputMode').value;
            const container = document.getElementById('type5Container');
            if (!container) { // Safety check
                 showError("Validation Error: Container not found.");
                 setTimeout(generateNextQuestion, 1500);
                 return;
            }


            // --- Retrieve valid combinations data ---
            let validCombinations = [];
            try {
                 const combinationsString = container.dataset.validCombinations?.replace(/'/g, "'") || '[]'; // Handle potential single quotes
                 validCombinations = JSON.parse(combinationsString);
                 // Basic validation of the parsed data
                 if (!Array.isArray(validCombinations) || (validCombinations.length > 0 && !Array.isArray(validCombinations[0]))) {
                      console.error("Invalid format for validCombinations dataset:", validCombinations);
                      validCombinations = []; // Reset to empty if format is wrong
                 }
            } catch (e) {
                console.error("Error parsing valid combinations:", e);
                showFeedback("Error validating answer data.", "warning");
                 setTimeout(generateNextQuestion, 1500);
                 return;
            }

            if (validCombinations.length === 0 || !validCombinations[0]) {
                 console.error("No valid combinations found for Type 5 validation.");
                 showFeedback("Error: Missing validation data.", "warning");
                 setTimeout(generateNextQuestion, 1500);
                 return;
            }

            const numBlanks = validCombinations[0].length; // Determine number of blanks
            const userAnswers = [];

            // --- Collect user answers ---
            for (let index = 0; index < numBlanks; index++) {
                let userAnswerText = '';
                if (mode === 'blocks') {
                    const blankEl = document.getElementById(`blank${index}`);
                    const droppedBlock = blankEl ? blankEl.querySelector('.dropped-block') : null;
                    userAnswerText = droppedBlock ? droppedBlock.textContent.trim() : '';
                } else {
                    const inputEl = document.querySelector(`.type5-text-input[data-blank-index="${index}"]`);
                    userAnswerText = inputEl ? inputEl.value.trim() : '';
                }
                 userAnswers.push(normalizeJapanese(userAnswerText)); // Normalize immediately
            }

            console.log("User Answers (Normalized):", userAnswers);
            console.log("Valid Combinations:", validCombinations);

            // --- Check if userAnswers array EXACTLY matches any valid combination array ---
            let isCorrect = false;
            for (const validCombo of validCombinations) {
                 // Ensure the combo being checked is valid
                 if (!Array.isArray(validCombo) || validCombo.length !== numBlanks) {
                      console.warn("Skipping invalid format in validCombinations:", validCombo);
                      continue;
                 }
                 const normalizedValidCombo = validCombo.map(normalizeJapanese);
                 // Compare arrays element by element
                 if (userAnswers.every((val, index) => val === normalizedValidCombo[index])) {
                     isCorrect = true;
                     console.log("Match found with combination:", validCombo);
                     break; // Found a match
                 }
            }

            // --- Show Feedback ---
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");

             // Optional: Add visual feedback to blanks on incorrect
             if (!isCorrect) {
                 for (let index = 0; index < numBlanks; index++) {
                      const blankContainer = document.getElementById(`blank${index}`);
                      if (blankContainer) {
                          blankContainer.style.borderBottomColor = '#d32f2f';
                          setTimeout(() => { blankContainer.style.borderBottomColor = ''; }, 1400);
                      }
                 }
             }

            // --- Proceed to next question ---
            // handleAnswerResult(currentQuestion, isCorrect); // Decide if Type 5 affects relearn
            setTimeout(generateNextQuestion, 1500);
        }


        // --- Relearn Pool Logic ---
        function handleAnswerResult(question, isCorrect) {
             // Only apply to types intended for relearn (Type 1, Type 2)
             if (!question || !(question.word || question.blank)) return;
             if (!currentLesson.relearnpool) return; // Skip if relearn pool is disabled for the lesson

            const targetPool = question.word ? relearnType1 : relearnType2;
            const poolKey = question.word ? `relearnType1_${lang}` : `relearnType2_${lang}`;

            // Find if the item exists in the pool (match by word or sentence structure if needed)
            // Simple match by word/blank content for now
            const itemIdentifier = question.word || (Array.isArray(question.blank) ? question.blank[0] : question.blank);
             let existingIndex = -1;
             if (question.word) {
                 existingIndex = targetPool.findIndex(item => item.word === itemIdentifier);
             } else {
                 existingIndex = targetPool.findIndex(item => {
                     const itemBlank = Array.isArray(item.blank) ? item.blank[0] : item.blank;
                     return itemBlank === itemIdentifier && item.sentence === question.sentence; // Add sentence match for grammar
                 });
             }


            if (isCorrect) {
                if (existingIndex !== -1) {
                    // Item exists, increment correct count
                    const item = targetPool[existingIndex];
                    item.correctCount = (item.correctCount || 0) + 1;
                    item.lastPracticed = Date.now();
                    // Check if it reached the repetition goal
                     const requiredReps = item.pracrepetition || currentLesson.pracrepetition || 3; // Get goal from item, lesson, or default
                    if (item.correctCount >= requiredReps) {
                        console.log(`Item "${itemIdentifier}" mastered (${item.correctCount}/${requiredReps}), removing from relearn pool.`);
                        targetPool.splice(existingIndex, 1); // Remove from pool
                    } else {
                         console.log(`Item "${itemIdentifier}" correct (${item.correctCount}/${requiredReps})`);
                    }
                } else {
                     // Item not in pool, but answered correctly (likely a 'new' item first time)
                     // Do nothing, don't add on first correct answer.
                     console.log(`New item "${itemIdentifier}" answered correctly first time.`);
                }
            } else {
                // Incorrect answer
                if (existingIndex !== -1) {
                    // Item exists, reset correct count
                    targetPool[existingIndex].correctCount = 0;
                    targetPool[existingIndex].lastPracticed = Date.now();
                     console.log(`Item "${itemIdentifier}" incorrect, count reset.`);
                } else {
                    // Item doesn't exist (was likely a 'new' item), add it to the pool
                    const newItem = {
                        ...question, // Copy original question data
                        correctCount: 0,
                        lastPracticed: Date.now()
                    };
                    targetPool.push(newItem);
                     console.log(`New item "${itemIdentifier}" incorrect, added to relearn pool.`);
                }
            }

            // Save updated pool to localStorage
            localStorage.setItem(poolKey, JSON.stringify(targetPool));
        }
        // --- End Relearn Pool Logic ---


        // Japanese Normalization
        function normalizeJapanese(text) {
            if (typeof text !== 'string') return '';
            try {
                return wanakana.toHiragana(
                    text.normalize('NFKC') // Normalize full-width characters etc.
                        .replace(/[.,;:!?。、・]/g, '') // Remove common punctuation
                        .toLowerCase() // Consistent casing
                        .trim() // Remove leading/trailing whitespace
                );
            } catch (e) {
                 console.error("Wanakana normalization failed for:", text, e);
                 return text.toLowerCase().trim(); // Fallback
            }
        }

        // Disable Buttons during processing
        function disableButtons(state) {
            document.querySelectorAll('button').forEach(btn => btn.disabled = state);
            document.querySelectorAll('input').forEach(inp => inp.disabled = state);
             document.querySelectorAll('select').forEach(sel => sel.disabled = state);
             // Make canvas non-interactive if needed
             if (canvas) {
                 canvas.style.pointerEvents = state ? 'none' : 'auto';
             }
        }

        // Show Global Feedback
        function showFeedback(message, className) {
            // Remove existing feedback first
            const existingFeedback = document.querySelector('.global-feedback');
            if (existingFeedback) existingFeedback.remove();

            const feedback = document.createElement('div');
            feedback.className = `global-feedback ${className}`; // correct, incorrect, warning
            feedback.innerHTML = `<span>${message}</span>`;
            document.body.appendChild(feedback);

            // Automatically remove after a delay
             setTimeout(() => {
                 feedback.style.animation = 'fadeOut 0.5s ease forwards'; // Use fadeOut animation
                 feedback.addEventListener('animationend', () => feedback.remove(), { once: true });
             }, 1500); // Start fade-out after 1.5 seconds
        }

        // Show Global Error
        function showError(message) {
            // Remove existing error first
            const existingError = document.querySelector('.global-error');
            if (existingError) existingError.remove();

            const errorDiv = document.createElement('div');
            errorDiv.className = 'global-error';
            errorDiv.innerHTML = `
                <h4 style="margin-bottom: 5px; color: #b71c1c;">Error</h4>
                <p>${message}</p>
            `;
            document.body.appendChild(errorDiv);
            // Longer timeout for errors
            setTimeout(() => errorDiv.remove(), 5000);
        }


        // --- Type 5 Drag & Drop ---
        let draggedElement = null;

        function initType5DragDrop() {
            document.querySelectorAll('.draggable').forEach(block => {
                block.removeEventListener('dragstart', dragStart); // Remove previous listeners
                block.removeEventListener('dragend', dragEnd);
                block.addEventListener('dragstart', dragStart);
                block.addEventListener('dragend', dragEnd);
            });
            // Ensure blanks are ready for dropping
             document.querySelectorAll('.type5-blank').forEach(blank => {
                 blank.removeEventListener('drop', drop);
                 blank.removeEventListener('dragover', allowDrop);
                 blank.addEventListener('drop', drop);
                 blank.addEventListener('dragover', allowDrop);
             });
        }

        function allowDrop(ev) {
            ev.preventDefault(); // Necessary to allow dropping
            // Optional: Add visual feedback on hover
             const target = ev.target.closest('.type5-blank');
             if (target && target.children.length === 0) {
                 // Add a class for hover effect if desired
             }
        }

        function dragStart(ev) {
            if (!ev.target.classList.contains('draggable')) return; // Ensure it's a draggable block
            ev.target.classList.add('dragging');
            draggedElement = ev.target;
            ev.dataTransfer.setData("text/plain", ev.target.textContent); // Store data
            ev.dataTransfer.effectAllowed = "move";
        }

        function dragEnd(ev) {
             if (draggedElement) { // Check if drag started properly
                 draggedElement.classList.remove('dragging');
             }
            draggedElement = null; // Clear dragged element reference
        }

        function drop(ev, blankIndex) { // Pass blankIndex if using inline ondrop="drop(event, index)"
            ev.preventDefault();
            const targetBlank = ev.target.closest('.type5-blank'); // Find the blank container

            if (targetBlank && targetBlank.children.length === 0 && draggedElement) { // Only drop if blank is empty
                 // Move the dragged element into the blank
                 draggedElement.classList.remove('draggable', 'dragging');
                 draggedElement.classList.add('dropped-block');
                 draggedElement.draggable = false; // Make it non-draggable once dropped
                 draggedElement.removeEventListener('dragstart', dragStart); // Remove drag listeners
                 draggedElement.removeEventListener('dragend', dragEnd);

                 // Add click listener to return the block
                 draggedElement.onclick = returnBlockToTray;

                 targetBlank.appendChild(draggedElement); // Add to the blank
                 draggedElement = null; // Clear reference
            } else if (draggedElement) {
                 // Drop failed (e.g., blank not empty), do nothing or provide feedback
                 console.log("Drop target not empty or invalid.");
            }
        }

        function returnBlockToTray(ev) {
             const block = ev.target.closest('.dropped-block');
             const initialTray = document.getElementById('type5InitialTray');
             if (block && initialTray) {
                 block.classList.remove('dropped-block');
                 block.classList.add('draggable');
                 block.draggable = true;
                 block.onclick = null; // Remove return listener
                 block.addEventListener('dragstart', dragStart); // Re-add drag listeners
                 block.addEventListener('dragend', dragEnd);
                 initialTray.appendChild(block); // Move back to tray
                 // Optional: Shuffle tray again?
                 // const blocksToShuffle = Array.from(initialTray.children);
                 // shuffleArray(blocksToShuffle).forEach(b => initialTray.appendChild(b));
             }
        }
        // --- End Type 5 Drag & Drop ---


        // --- Type 6 Canvas Drawing & Validation (Keep existing logic) ---
        // initCanvas, startStroke, drawStroke, endStroke, getCanvasPosition,
        // resetCanvas, validateKanji, disableHandwriteControls, resetValidationState, etc.

        function initCanvas() {
            strokes = []; // Reset strokes for the new question
            canvas = document.getElementById('kanjiCanvas');
            if (!canvas) {
                 console.error("Kanji canvas element not found!");
                 return;
            }
            ctx = canvas.getContext('2d');

            // Set fixed size or get from container? Fixed for now.
            const canvasSize = 300;
            canvas.width = canvasSize;
            canvas.height = canvasSize;

            ctx.lineWidth = 5; // Adjust thickness if needed
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round'; // Smoother corners
            ctx.strokeStyle = '#8B0000'; // Dark red

            // Clear previous drawings
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Remove old listeners before adding new ones
            canvas.removeEventListener('mousedown', startStroke);
            canvas.removeEventListener('mousemove', drawStroke);
            canvas.removeEventListener('mouseup', endStroke);
            canvas.removeEventListener('mouseleave', endStroke);
            canvas.removeEventListener('touchstart', startStroke, { passive: false }); // Use passive: false for touchmove prevention
            canvas.removeEventListener('touchmove', drawStroke, { passive: false });
            canvas.removeEventListener('touchend', endStroke);
            canvas.removeEventListener('touchcancel', endStroke); // Handle cancellation

            // Add Event listeners for mouse
            canvas.addEventListener('mousedown', startStroke);
            canvas.addEventListener('mousemove', drawStroke);
            canvas.addEventListener('mouseup', endStroke);
            canvas.addEventListener('mouseleave', endStroke); // Stop drawing if mouse leaves canvas

            // Add Event listeners for touch
            canvas.addEventListener('touchstart', startStroke, { passive: false });
            canvas.addEventListener('touchmove', drawStroke, { passive: false });
            canvas.addEventListener('touchend', endStroke);
            canvas.addEventListener('touchcancel', endStroke); // Handle interruption

            isDrawing = false; // Ensure drawing flag is reset
            isHandwriteLocked = false; // Ensure lock is reset
            resetValidationState(); // Reset button states etc.
        }


        function startStroke(e) {
            // Prevent default touch behavior like scrolling
            if (e.type === 'touchstart') e.preventDefault();
            if (isHandwriteLocked) return; // Don't draw if locked

            isDrawing = true;
            strokes.push([]); // Start a new stroke array
            const pos = getCanvasPosition(e);
            if (!pos) return;

            // Add first point to the current stroke
            strokes[strokes.length - 1].push({ x: pos.x, y: pos.y, t: Date.now() });

            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
        }

        function drawStroke(e) {
            if (!isDrawing || isHandwriteLocked) return;
            // Prevent default touch behavior like scrolling
            if (e.type === 'touchmove') e.preventDefault();

            const pos = getCanvasPosition(e);
            if (!pos) return;

            const currentStroke = strokes[strokes.length - 1];
            if (!currentStroke) return; // Safety check

            // Add point to the current stroke array
            currentStroke.push({ x: pos.x, y: pos.y, t: Date.now() });

            // Draw line segment on canvas
            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }

        function endStroke(e) {
            if (!isDrawing) return; // Only end if currently drawing
            // Prevent default touch behavior if applicable
            if (e.type === 'touchend' || e.type === 'touchcancel') e.preventDefault();

            isDrawing = false;
            // No need to ctx.closePath() for simple lines
            // ctx.closePath(); // Only needed if filling shapes

             // Optional: Smooth the last drawn stroke? (Advanced)
        }


        function getCanvasPosition(e) {
            if (!canvas) return null;
            const rect = canvas.getBoundingClientRect();
            let clientX, clientY;

            if (e.type.startsWith('touch')) {
                // Use the first touch point
                if (e.touches.length > 0) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches.length > 0) {
                    // Use changedTouches for touchend/touchcancel
                     clientX = e.changedTouches[0].clientX;
                     clientY = e.changedTouches[0].clientY;
                } else {
                    return null; // No touch points available
                }
            } else {
                // Mouse event
                clientX = e.clientX;
                clientY = e.clientY;
            }

             // Calculate position relative to canvas, considering scaling/scrolling
             const scaleX = canvas.width / rect.width;
             const scaleY = canvas.height / rect.height;
             const x = (clientX - rect.left) * scaleX;
             const y = (clientY - rect.top) * scaleY;

            // Clamp position to canvas boundaries
            return {
                x: Math.max(0, Math.min(canvas.width, x)),
                y: Math.max(0, Math.min(canvas.height, y))
            };
        }

        function resetCanvas() {
            if (ctx && canvas) {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
            }
            strokes = []; // Clear stroke data
            isDrawing = false;
            resetValidationState(); // Re-enable buttons, reset flags
        }

        // --- START Stroke Analysis Code ---

        // Stroke type classification system
        const StrokeTypes = {
            HORIZONTAL: 'HORIZONTAL', VERTICAL: 'VERTICAL',
            RIGHT_FALLING: 'RIGHT_FALLING', LEFT_FALLING: 'LEFT_FALLING',
            RIGHT_HOOK: 'RIGHT_HOOK', LEFT_HOOK: 'LEFT_HOOK',
            CURVE_RIGHT: 'CURVE_RIGHT', CURVE_LEFT: 'CURVE_LEFT',
            DOT: 'DOT', THROW: 'THROW', RISE: 'RISE', TICK: 'TICK',
            UNKNOWN: 'UNKNOWN'
        };

        // Configuration for analysis
        const AnalysisConfig = {
            DOT_MAX_LENGTH_RATIO: 0.08, // Max length relative to canvas width to be considered a dot
            HOOK_ANGLE_THRESHOLD: 65,  // Minimum angle change (degrees) to detect a hook potential
            CURVE_DEVIATION_THRESHOLD_RATIO: 0.05, // Minimum avg deviation relative to canvas width for curve
            MIN_CURVE_LENGTH_RATIO: 0.1, // Minimum stroke length relative to canvas width to be curve candidate
            MAX_STRAIGHTNESS_DEVIATION_RATIO: 0.04, // Max deviation for straight lines
            KEY_POINTS_COUNT: 5, // Number of points to analyze along the stroke (start, end, intermediates)
        };


        // Helper: Calculate angle change between three points
        function calculateAngleChange(p1, p2, p3) {
            const v1x = p2.x - p1.x;
            const v1y = p2.y - p1.y;
            const v2x = p3.x - p2.x;
            const v2y = p3.y - p2.y;
            const dot = v1x * v2x + v1y * v2y;
            const mag1 = Math.hypot(v1x, v1y);
            const mag2 = Math.hypot(v2x, v2y);
            if (mag1 === 0 || mag2 === 0) return 0;
            const cosTheta = Math.min(Math.max(dot / (mag1 * mag2), -1), 1);
            return Math.acos(cosTheta) * (180 / Math.PI); // Angle in degrees
        }

        // Helper: Get evenly spaced points along a stroke path
        function getEvenlySpacedPoints(points, numPoints) {
            if (!points || points.length < 2) return points || [];
            if (points.length <= numPoints) return points; // Return original if fewer points than requested

            let totalLength = 0;
            for (let i = 1; i < points.length; i++) {
                totalLength += Math.hypot(points[i].x - points[i-1].x, points[i].y - points[i-1].y);
            }

            const segmentLength = totalLength / (numPoints - 1);
            const spacedPoints = [points[0]]; // Start with the first point
            let currentDist = 0;
            let targetDist = segmentLength;
            let segmentStartIdx = 0;

            while (spacedPoints.length < numPoints - 1 && segmentStartIdx < points.length - 1) {
                const p1 = points[segmentStartIdx];
                const p2 = points[segmentStartIdx + 1];
                const distBetween = Math.hypot(p2.x - p1.x, p2.y - p1.y);

                if (currentDist + distBetween >= targetDist) {
                    // The target point lies on the segment between p1 and p2
                    const remainingDist = targetDist - currentDist;
                    const ratio = remainingDist / distBetween;
                    const newX = p1.x + (p2.x - p1.x) * ratio;
                    const newY = p1.y + (p2.y - p1.y) * ratio;
                    spacedPoints.push({ x: newX, y: newY });

                    targetDist += segmentLength; // Move to the next target distance
                    // We might find multiple points on this segment, so don't advance segmentStartIdx yet
                } else {
                    currentDist += distBetween;
                    segmentStartIdx++; // Move to the next segment
                }
                 // Safety break
                 if (spacedPoints.length >= numPoints * 2) {
                     console.warn("Stuck in getEvenlySpacedPoints loop");
                     break;
                 }
            }

            spacedPoints.push(points[points.length - 1]); // Add the last point
            return spacedPoints;
        }


        // Helper: Calculate deviation from a straight line
        function calculateMaxDeviation(pointsToCheck, lineStart, lineEnd) {
            if (!pointsToCheck || pointsToCheck.length < 1) return 0;
            const dx = lineEnd.x - lineStart.x;
            const dy = lineEnd.y - lineStart.y;
            const lengthSq = dx * dx + dy * dy;
            if (lengthSq === 0) return 0; // Start and end points are the same

            let maxPerpendicularDistSq = 0;

            for (let i = 0; i < pointsToCheck.length; i++) {
                const p = pointsToCheck[i];
                // Calculate perpendicular distance squared from point p to the infinite line defined by (lineStart, lineEnd)
                const distSq = (Math.abs(dy * p.x - dx * p.y + lineEnd.x * lineStart.y - lineEnd.y * lineStart.x) ** 2) / lengthSq;
                maxPerpendicularDistSq = Math.max(maxPerpendicularDistSq, distSq);
            }
            // Return the actual max perpendicular distance
            return Math.sqrt(maxPerpendicularDistSq);
        }


        // Core Stroke Analysis Function - REVISED for better falling/curve distinction & noise reduction
        function analyzeStroke(points, canvasWidth) {
            // Need at least 3 points for robust analysis (start, middle, end)
            if (!points || points.length < 3) return StrokeTypes.UNKNOWN;

            // --- 1. Basic Properties & End-Point Noise Reduction ---
            // Use points excluding the very first and very last for some calculations
            // to reduce sensitivity to start/end hooks/flicks.
            const corePoints = points.length > 4 ? points.slice(1, -1) : points; // Use inner points if enough exist
            const start = points[0];
            const end = points[points.length - 1];
            const dx = end.x - start.x; // Overall direction X
            const dy = end.y - start.y; // Overall direction Y
            const length = Math.hypot(dx, dy);
             // Overall angle, adjusted to be 0 to 360 degrees (0 is right, 90 is down)
             let angle = Math.atan2(dy, dx) * (180 / Math.PI);
             if (angle < 0) angle += 360;


            // --- 2. Dot Detection (Based on overall length) ---
            if (length < canvasWidth * AnalysisConfig.DOT_MAX_LENGTH_RATIO) {
                return StrokeTypes.DOT;
            }

            // --- 3. Straightness Check (Using core points against overall start-end line) ---
            const maxDeviation = calculateMaxDeviation(corePoints, start, end);
            const isStraight = maxDeviation < canvasWidth * AnalysisConfig.MAX_STRAIGHTNESS_DEVIATION_RATIO;

            // --- 4. Straight Stroke Classification (If straight) ---
            if (isStraight) {
                // Angle ranges (0=right, 90=down, 180=left, 270=up)
                if (angle < 20 || angle > 340) return StrokeTypes.HORIZONTAL;     // Right horizontal
                if (angle > 160 && angle < 200) return StrokeTypes.HORIZONTAL;     // Left horizontal
                if (angle > 70 && angle < 110) return StrokeTypes.VERTICAL;       // Down vertical
                if (angle > 250 && angle < 290) return StrokeTypes.VERTICAL;       // Up vertical (Rise)
                if (angle >= 20 && angle <= 70) return StrokeTypes.RIGHT_FALLING; // Down-right (Na)
                if (angle >= 110 && angle <= 160) return StrokeTypes.LEFT_FALLING;  // Down-left (Pie)
                if (angle >= 290 && angle <= 340) return StrokeTypes.THROW;         // Up-right (Ti/Throw)
                if (angle >= 200 && angle <= 250) return StrokeTypes.LEFT_FALLING;  // Up-left (can be Pie variant)

                // Fallback for ambiguous straight strokes based on quadrant
                console.warn("Ambiguous straight stroke angle:", angle.toFixed(1));
                if (dy > 0) return dx > 0 ? StrokeTypes.RIGHT_FALLING : StrokeTypes.LEFT_FALLING;
                else return dx > 0 ? StrokeTypes.THROW : StrokeTypes.LEFT_FALLING;
            }

            // --- 5. Non-Straight Stroke Analysis ---

            // 5a. Prioritize Overall Falling Direction (捺 - Nà, 撇 - Piě)
            // Check if the stroke moves significantly down AND significantly left/right overall
            const verticalMovement = Math.abs(dy);
            const horizontalMovement = Math.abs(dx);

            // Thresholds relative to stroke length (tune these)
            const downThreshold = length * 0.4; // Must move down at least 40% of its length
            const sideThreshold = length * 0.2; // Must move sideways at least 20% of its length

            if (dy > downThreshold) { // Clearly moves downward
                if (dx > sideThreshold) {
                    console.log("Classified as RIGHT_FALLING (Priority)");
                    return StrokeTypes.RIGHT_FALLING; // Primarily Down-Right (捺 - Nà like)
                }
                if (dx < -sideThreshold) {
                     console.log("Classified as LEFT_FALLING (Priority)");
                    return StrokeTypes.LEFT_FALLING; // Primarily Down-Left (撇 - Piě like)
                }
                 // If it moves down but not much sideways, could still be a curved vertical or hook...
                 // Continue analysis for hooks/curves
            }


            // 5b. Hook Detection (Check for sharp turns *within* the core points)
            const keyPoints = getEvenlySpacedPoints(corePoints, AnalysisConfig.KEY_POINTS_COUNT);
            let maxAngleChange = 0;
            let hookPointIndex = -1;
            if (keyPoints.length >= 3) {
                for (let i = 1; i < keyPoints.length - 1; i++) {
                    const change = calculateAngleChange(keyPoints[i - 1], keyPoints[i], keyPoints[i + 1]);
                    if (change > maxAngleChange) {
                        maxAngleChange = change;
                        hookPointIndex = i;
                    }
                }
            }

            if (maxAngleChange > AnalysisConfig.HOOK_ANGLE_THRESHOLD) {
                // Analyze direction *after* the hook point
                 if (hookPointIndex >= 0 && hookPointIndex < keyPoints.length - 1) {
                     const preHookVec = { x: keyPoints[hookPointIndex].x - keyPoints[hookPointIndex - 1].x, y: keyPoints[hookPointIndex].y - keyPoints[hookPointIndex - 1].y };
                     const postHookVec = { x: keyPoints[hookPointIndex + 1].x - keyPoints[hookPointIndex].x, y: keyPoints[hookPointIndex + 1].y - keyPoints[hookPointIndex].y };
                     let postHookAngle = Math.atan2(postHookVec.y, postHookVec.x) * (180 / Math.PI);
                     if (postHookAngle < 0) postHookAngle += 360; // Normalize 0-360

                     // Basic hook classification (can be refined)
                     // Example: Vertical stroke turning left -> LEFT_HOOK (e.g., 竖钩 shùgōu)
                     // Example: Horizontal stroke turning down -> RIGHT_HOOK (e.g., 横钩 hénggōu - often more rightward)

                     // If mostly vertical before hook, and turns left/up-left after -> LEFT_HOOK
                     if (Math.abs(preHookVec.x) < Math.abs(preHookVec.y) && postHookAngle > 120 && postHookAngle < 300) {
                          console.log("Classified as LEFT_HOOK");
                          return StrokeTypes.LEFT_HOOK;
                     }
                     // If mostly horizontal before hook, and turns down/down-right after -> RIGHT_HOOK (common case)
                      if (Math.abs(preHookVec.y) < Math.abs(preHookVec.x) && postHookAngle > 30 && postHookAngle < 150) {
                         console.log("Classified as RIGHT_HOOK");
                         return StrokeTypes.RIGHT_HOOK;
                     }
                     // Add more specific hook rules here (e.g., 斜钩 xiégōu - diagonal hook)
                     console.log(`Potential Hook: MaxChange=${maxAngleChange.toFixed(1)} PostAngle=${postHookAngle.toFixed(1)}`);
                 }
            }

            // 5c. General Curve Classification (If not straight, not priority falling, not hook)
            // Use cross product to determine the general direction of curvature relative to the start-end line.
            // Check midpoint of the *core* points
            const midPointIndex = Math.floor(corePoints.length / 2);
            const midPoint = corePoints[midPointIndex];
            const crossProduct = dx * (midPoint.y - start.y) - dy * (midPoint.x - start.x);

            // We already know it's not straight (maxDeviation is high)
            // Classify based on which side the midpoint deviates to.
            if (crossProduct > 0) { // Midpoint is "left" of the line from start to end
                console.log("Classified as CURVE_LEFT");
                return StrokeTypes.CURVE_LEFT;
            } else if (crossProduct < 0) { // Midpoint is "right" of the line from start to end
                 console.log("Classified as CURVE_RIGHT");
                return StrokeTypes.CURVE_RIGHT;
            } else {
                // Cross product is zero or very small - may be complex S-curve or nearly straight fallback
                 console.warn("Non-straight stroke with near-zero cross product. Falling back.");
                 // Fallback based on overall angle
                 if (angle >= 20 && angle <= 160) return dy > dx ? StrokeTypes.VERTICAL : StrokeTypes.RIGHT_FALLING; // Mostly Down
                 if (angle > 160 && angle < 200) return StrokeTypes.HORIZONTAL; // Mostly Left
                 if (angle >= 200 && angle <= 340) return dy < dx ? StrokeTypes.VERTICAL : StrokeTypes.LEFT_FALLING; // Mostly Up
                 return StrokeTypes.HORIZONTAL; // Default Right
            }
        }


        // Stroke compatibility matrix - checks if detected type is acceptable for expected type
        function directionMatches(expected, detected) {
             if (expected === detected) return true;

            // Define acceptable variations (tweak as needed)
             const compatibility = {
                [StrokeTypes.HORIZONTAL]: [StrokeTypes.TICK],
                [StrokeTypes.VERTICAL]: [StrokeTypes.RISE],
                [StrokeTypes.RIGHT_FALLING]: [StrokeTypes.CURVE_RIGHT, StrokeTypes.THROW, StrokeTypes.RIGHT_HOOK],
                [StrokeTypes.LEFT_FALLING]: [StrokeTypes.CURVE_LEFT, StrokeTypes.LEFT_HOOK],
                [StrokeTypes.RIGHT_HOOK]: [StrokeTypes.RIGHT_FALLING], // Can a hook be drawn as a simple fall?
                [StrokeTypes.LEFT_HOOK]: [StrokeTypes.LEFT_FALLING],
                [StrokeTypes.CURVE_RIGHT]: [StrokeTypes.RIGHT_FALLING],
                [StrokeTypes.CURVE_LEFT]: [StrokeTypes.LEFT_FALLING],
                [StrokeTypes.THROW]: [StrokeTypes.RIGHT_FALLING], // Can a throw be drawn as simple fall?
                [StrokeTypes.DOT]: [], // Dots usually need to be dots
                [StrokeTypes.TICK]: [StrokeTypes.HORIZONTAL],
                [StrokeTypes.RISE]: [StrokeTypes.VERTICAL],
             };

             return (compatibility[expected] || []).includes(detected);
        }


        // Stroke Order Validation (Compares user strokes to expected patterns)
        async function validateStrokeOrder(userStrokes, kanjiData) {
            try {
                const canvasRef = document.getElementById('kanjiCanvas'); // Get canvas ref for width
                if (!canvasRef) return 0;
                const canvasWidth = canvasRef.width;

                // Patterns to check: official + alternatives
                const allValidPatterns = [
                    kanjiData.strokeTypes, // Official pattern
                    ...(kanjiData.alternativeStrokeTypes || []) // Add alternative patterns if they exist
                ].filter(p => Array.isArray(p) && p.length > 0); // Ensure patterns are valid arrays

                let bestAccuracy = 0;
                let bestMatchInfo = null;

                // Validate against all available patterns
                for (const pattern of allValidPatterns) {
                    if (userStrokes.length !== pattern.length) continue; // Skip if stroke count doesn't match pattern

                    let correctCount = 0;
                    const currentDetected = [];
                    const matchDetails = [];

                    for (let i = 0; i < pattern.length; i++) {
                        const detectedType = analyzeStroke(userStrokes[i], canvasWidth);
                        currentDetected.push(detectedType);
                        const isMatch = directionMatches(pattern[i], detectedType);
                        if (isMatch) {
                            correctCount++;
                        }
                        matchDetails.push({
                            'Stroke #': i + 1,
                            'Expected': pattern[i],
                            'Detected': detectedType,
                            'Match': isMatch ? '✓' : '✗'
                        });
                    }

                    const accuracy = (correctCount / pattern.length) * 100;
                    if (accuracy > bestAccuracy) {
                        bestAccuracy = accuracy;
                        bestMatchInfo = {
                             patternType: pattern === kanjiData.strokeTypes ? 'Official' : 'Alternative',
                             details: matchDetails
                        };
                    }
                }

                // Console logging for debugging
                console.groupCollapsed(`Stroke Validation Result for ${kanjiData.kanji}`);
                if (bestMatchInfo) {
                    console.log(`Best Match Pattern: ${bestMatchInfo.patternType}`);
                    console.table(bestMatchInfo.details);
                    console.log(`Final Accuracy: ${bestAccuracy.toFixed(2)}%`);
                } else {
                    console.log(`No matching stroke patterns found (User: ${userStrokes.length} strokes)`);
                    if (allValidPatterns.length > 0) {
                         console.log(`Expected strokes: ${allValidPatterns[0].length}`);
                    } else {
                         console.log(`No expected stroke patterns defined for ${kanjiData.kanji}`);
                    }
                }
                console.groupEnd();

                return bestAccuracy;

            } catch (error) {
                console.error('Stroke order validation error:', error);
                return 0; // Return 0% accuracy on error
            }
        }

        // --- END Stroke Analysis Code ---

        // Validate Kanji
        async function validateKanji() {
            const container = document.querySelector('.kanji-container');
            const expectedKanji = container ? container.dataset.kanji : null;

            if (window.isAnswered || isHandwriteLocked || !expectedKanji) return;

            window.isAnswered = true;
            isHandwriteLocked = true; // Lock immediately
            disableHandwriteControls(true);

            console.log(`Validating drawing for: ${expectedKanji}`);
            console.log(`User drew ${strokes.length} strokes.`);

            try {
                // Find Kanji data from the loaded type6Data
                const kanjiData = type6Data.find(k => k.kanji === expectedKanji);
                if (!kanjiData || !kanjiData.strokes || !kanjiData.strokeTypes) {
                    showFeedback("Kanji data or stroke pattern missing!", "warning");
                    resetValidationState(); // Unlock for retry
                    return;
                }

                // 1. Basic Stroke Count Check
                if (strokes.length !== kanjiData.strokes) {
                    showFeedback(`Incorrect stroke count (Expected ${kanjiData.strokes}, Got ${strokes.length})`, "incorrect");
                    resetValidationState(); // Unlock for retry
                    return;
                }

                // 2. Validate Stroke Order and Shape using the analysis functions
                const accuracy = await validateStrokeOrder(strokes, kanjiData); // Pass user strokes and kanji data

                // 3. Determine required accuracy threshold
                let requiredAccuracy = parseFloat(currentLesson?.settings?.requiredStrokeAccuracy || kanjiData.requiredAccuracy || 75); // Lesson setting > Kanji setting > Default
                if (requiredAccuracy <= 1 && requiredAccuracy > 0) {
                     requiredAccuracy *= 100; // Convert ratio (e.g., 0.75) to percentage
                }
                 requiredAccuracy = Math.max(0, Math.min(100, requiredAccuracy)); // Clamp between 0 and 100

                console.log(`Stroke Accuracy: ${accuracy.toFixed(2)}% (Required: ${requiredAccuracy}%)`);

                // 4. Provide Feedback based on accuracy
                if (accuracy >= requiredAccuracy) {
                    showFeedback(`Correct! (${accuracy.toFixed(2)}%)`, "correct");
                    // Don't reset state here, wait for timeout in handleCorrectSubmission
                    handleCorrectSubmission(); // Handles moving to the next question
                } else {
                    // Determine feedback type (warning for close calls, incorrect otherwise)
                    const feedbackType = accuracy >= (requiredAccuracy * 0.6) ? "warning" : "incorrect"; // e.g., Warning if > 60% of required
                    const feedbackMessage = accuracy >= (requiredAccuracy * 0.6)
                        ? `Close! ${accuracy.toFixed(1)}%. Adjust & retry.`
                        : `Incorrect (${accuracy.toFixed(1)}%). Needs improvement.`;

                    showFeedback(feedbackMessage, feedbackType);
                    resetValidationState(); // Unlock for retry
                }

            } catch (error) {
                console.error('Kanji validation failed:', error);
                showFeedback("Validation error. Please try again.", "warning");
                resetValidationState(); // Unlock on error
            }
        }

        // Helper function to proceed after correct handwriting submission
        function handleCorrectSubmission() {
            // isHandwriteLocked should already be true
            // Buttons should already be disabled

            // Clear any existing timeout just in case
            if (currentTimeout) clearTimeout(currentTimeout);

            // Proceed to the next question after a delay
            currentTimeout = setTimeout(() => {
                generateNextQuestion();
                // resetValidationState() will be called by initCanvas for the new question
                // Resetting lock here is redundant as initCanvas does it.
            }, 1500);
        }

        function disableHandwriteControls(disabled) {
            document.querySelectorAll('.kanji-controls button').forEach(btn => {
                btn.disabled = disabled;
                btn.style.opacity = disabled ? 0.6 : 1; // Visual feedback
                btn.style.cursor = disabled ? 'not-allowed' : 'pointer';
            });
        }

        function resetValidationState() {
            window.isAnswered = false;
            isHandwriteLocked = false;
            disableHandwriteControls(false); // Re-enable buttons
             // No need to reset strokes here, resetCanvas or initCanvas handles that
        }

        // --- End Type 6 ---


        // --- General Lesson Flow ---

        // Update progress bar
        function updateProgress() {
            // Find the lesson config again in case it was updated (though unlikely mid-lesson)
            const lessonConfig = currentLesson || {}; // Use the stored global config
            const totalQ = lessonConfig.questionsPerLesson || questionsPerLesson; // Use lesson specific or default
            const progress = totalQ > 0 ? (questionsCompleted / totalQ) * 100 : 0;
            document.getElementById('progressBar').style.width = `${Math.min(100, progress)}%`; // Cap at 100

            // Update title (optional)
             const lessonTitle = lessonConfig.title || document.title;
             document.title = `Livygo - ${lessonTitle} (${questionsCompleted}/${totalQ})`;
        }

        // Complete lesson and update progress
        function completeLesson() {
            console.log("Lesson complete!");
            showFeedback("Lesson Complete!", "correct"); // Show completion feedback

            // Update progress in localStorage (e.g., mark as completed, update counts)
            // This depends on how you track overall course progress.
            // For now, just redirecting.

            // Fade out and redirect back to main page
            document.body.style.transition = 'opacity 0.5s ease-out';
            document.body.style.opacity = '0';
            setTimeout(() => {
                 window.location.href = 'mainnightly.html'; // Redirect after fade
            }, 500);
        }
        // --- End General Lesson Flow ---

    </script>
    <script src="codeParser.js"></script>
</body>
</html>