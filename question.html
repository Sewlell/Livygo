<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Livygo - Question</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f4f4f4;
            position: relative;
        }

        /* Progress Bar */
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: #eee;
            z-index: 999;
        }

        .progress-bar {
            height: 100%;
            background-color: #8B0000;
            transition: width 0.3s ease;
        }

        /* Cutscene Styling */
        .cutscene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .cutscene-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .cutscene-content {
            font-size: 2rem;
            text-align: center;
            max-width: 800px;
            line-height: 1.5;
            z-index: 1000; /* Ensure this is higher than activity */
            pointer-events: auto; /* Enable clicks */
        }

        .skip-indicator {
            position: absolute;
            bottom: 2rem;
            animation: pulse 1.5s infinite;
            opacity: 0.7;
            font-size: 1.2rem;
        }

        /* Activity Styling */
        .activity {
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
            width: 90%;
            max-width: 600px;
            z-index: 1; /* Keep behind cutscene */
        }

        .activity.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* Question Styling */
        .question {
            font-size: 1.5rem;
            margin-bottom: 2rem;
        }

        .options {
            display: grid;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        button {
            padding: 1rem 2rem;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px);
        }

        input {
            padding: 1rem;
            width: 100%;
            margin: 1rem 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
        }

        /* Error Styling */
        .global-error {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ffebee;
            color: #b71c1c;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }

        @keyframes pulse {
            0% { transform: translateY(0); opacity: 0.7; }
            50% { transform: translateY(-5px); opacity: 1; }
            100% { transform: translateY(0); opacity: 0.7; }
        }

        .global-feedback {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 1rem 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s ease, fadeOut 0.5s ease 1s;
            color: white;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .global-feedback.correct {
            background-color: #4CAF50;
            border: 2px solid #388E3C;
        }

        .global-feedback.incorrect {
            background-color: #d32f2f;
            border: 2px solid #b71c1c;
        }

        .global-feedback::before {
            content: '';
            display: inline-block;
            width: 24px;
            height: 24px;
            background-size: contain;
            background-repeat: no-repeat;
        }

        .global-feedback.correct::before {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>');
        }

        .global-feedback.incorrect::before {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>');
        }

        @keyframes slideIn {
            from { top: -50px; opacity: 0; }
            to { top: 20px; opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Add warning feedback style */
        .global-feedback.warning {
            background-color: #FFC107;
            border: 2px solid #FFA000;
            color: #000;
        }

        .word-block {
            display: inline-block;
            min-width: auto;
            padding: 6px 10px;
            font-size: 1rem;
            background: #8B0000;
            color: white;
            border-radius: 4px;
            margin: 4px;
            cursor: pointer;
            text-align: center;
        }

        .blocks-tray {
            background: #f8f8f8;
            min-height: 60px;
            border-radius: 8px;
        }

        .sentence-builder {
            background: #fff;
            min-height: 80px;
            margin-top: 1rem;
            border-radius: 8px;
            border: 2px dashed #ccc;
        }

        .answer-area {
            min-height: 60px;
            border: 2px dashed #ccc;
            margin: 1rem 0;
        }

        .input-mode {
            margin-top: 1rem;
            padding: 1rem;
            background: #f8f8f8;
            border-radius: 8px;
            min-height: 80px;
        }

        .audio-player-container {
            text-align: center;
            margin: 1rem 0;
        }

        #type3InputContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        #type3TextInput {
            width: 300px;
            padding: 12px;
            font-size: 1.1rem;
            margin: 0.5rem 0;
        }

        #type3Submit {
            padding: 12px 24px;
            width: fit-content;
            margin: 0.5rem 0;
        }

        .type3-question-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .type3-options {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 1rem 0;
        }

        #textContainer input {
            width: 100%;
            max-width: 500px;
            padding: 12px;
            font-size: 1.1rem;
        }
    </style>
</head>
<body>
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <div class="cutscene-container" id="cutsceneContainer">
        <div class="cutscene-content" id="cutsceneContent"></div>
        <div class="skip-indicator">▼ Click to continue ▼</div>
    </div>

    <div class="activity" id="activity"></div>

    <script src="https://unpkg.com/wanakana@5.3.1/wanakana.min.js"></script>
    <script>
        // Configuration
        const urlParams = new URLSearchParams(window.location.search);
        const currentCode = urlParams.get('code') || '1001';
        const basePath = urlParams.get('basePath') || '/courses/JP-en/default/';
        const lang = localStorage.getItem('selectedLang') || 'JP-en';
        
        let questionsPerLesson = 5;
        let questionsCompleted = 0;
        let currentCutsceneIndex = 0;
        let cutscenes = [];
        let isCutsceneActive = false;
        let currentQuestion = null;

        // Data storage
        let type1Data = [];
        let type2Data = [];
        let type3Data = [];
        let type4Data = [];
        let enabledQuestionTypes = ['type1', 'type2', 'type3', 'type4'];
        let relearnType1 = JSON.parse(localStorage.getItem(`relearnType1_${lang}`)) || [];
        let relearnType2 = JSON.parse(localStorage.getItem(`relearnType2_${lang}`)) || [];
        let lessonProgress = {};
        let currentLesson = null;

        document.addEventListener('DOMContentLoaded', () => {
            const storedProgress = JSON.parse(localStorage.getItem(`lessonProgress_${lang}`)) || [];
            lessonProgress = storedProgress;

            // Load pathway structure first
            fetch(`/courses/${lang}/pathway_structure.json`)
            .then(response => response.json())
            .then(pathwayStructure => {
                // Find the current section
                const numericCode = parseInt(currentCode);
                const section = pathwayStructure.find(s => 
                    s.addressMap.some(range => 
                        numericCode >= range.rangeStart && 
                        numericCode <= range.rangeEnd
                    )
                );
                
                // Set enabled question types
                if(section?.settings?.enabledQuestionTypes) {
                    enabledQuestionTypes = section.settings.enabledQuestionTypes;
                }

                // Load other resources
                return Promise.all([
                    fetch(`${basePath}lesson_progress.json`).then(res => res.json()),
                    fetch(`${basePath}cutscenes.json`).then(res => res.json()),
                    enabledQuestionTypes.includes('type1') ? 
                        fetch(`${basePath}type1_vocabulary.json`).then(res => res.json()) : 
                        Promise.resolve([]),
                    enabledQuestionTypes.includes('type2') ? 
                        fetch(`${basePath}type2_grammar.json`).then(res => res.json()) : 
                        Promise.resolve([]),
                    enabledQuestionTypes.includes('type3') ? 
                        fetch(`${basePath}type3_listening.json`).then(res => res.json()) : 
                        Promise.resolve([]),
                    enabledQuestionTypes.includes('type4') ? 
                        fetch(`${basePath}type4_sentence.json`).then(res => res.json()) : 
                        Promise.resolve([])
                ]);
            })
            .then(([progressData, cutsceneData, vocab, grammar, listening, sentence]) => {
                // Ensure progressData is array
                if (!Array.isArray(progressData)) {
                    progressData = [];
                }

                // Find or create current lesson
                currentLesson = storedProgress.find(lp => lp.code === currentCode) || 
                            progressData.find(p => p.code === currentCode) || 
                            progressData.find(p => p.code === 'default') || {
                                code: currentCode,
                                title: 'Default Title',
                                total: 5,
                                current: 1,
                                questionsPerLesson: 10,
                                practicecirc: false,
                                relearnpool: true
                            };

                // Update questionsPerLesson
                questionsPerLesson = currentLesson.questionsPerLesson || 10;
                
                // Store updated progress
                if (!storedProgress.some(lp => lp.code === currentCode)) {
                    storedProgress.push(currentLesson);
                    localStorage.setItem(`lessonProgress_${lang}`, JSON.stringify(storedProgress));
                }

                // Filter questions
                const baseCode = currentCode.split('-')[0];
                type1Data = enabledQuestionTypes.includes('type1') ? 
                    vocab.filter(item => 
                        item.code.startsWith(baseCode) && 
                        CodeParser.compare(item.code, currentLesson.praclimit || '')
                    ) : [];
                
                type2Data = enabledQuestionTypes.includes('type2') ? 
                    grammar.filter(item => 
                        item.code.startsWith(baseCode) && 
                        CodeParser.compare(item.code, currentLesson.praclimit || '')
                    ) : [];

                type3Data = enabledQuestionTypes.includes('type3') ? 
                    listening.filter(item =>
                        item.code.startsWith(baseCode) &&
                        CodeParser.compare(item.code, currentLesson.praclimit || '',
                        q => q.answers?.text && Array.isArray(q.answers.text))
                    ) : [];

                type4Data = enabledQuestionTypes.includes('type4') ? 
                    sentence.filter(item =>
                        item.code.startsWith(baseCode) &&
                        CodeParser.compare(item.code, currentLesson.praclimit || '',
                        q => q.blocks && Array.isArray(q.blocks))
                    ) : [];

                // Handle cutscenes
                const currentCutscene = cutsceneData.find(c => c.code === currentCode);
                if (currentCutscene?.nocutsc) {
                    document.getElementById('cutsceneContainer').remove();
                    startLesson();
                } else if (currentCutscene?.sequence) {
                    cutscenes = currentCutscene.sequence.flatMap(scene => 
                        scene.lines.join('\n').split(/\/{3,}/).map(part => ({
                            lines: part.trim().split('\n')
                        }))
                    );
                    showCutscene(0);
                } else {
                    document.getElementById('cutsceneContainer').remove();
                    startLesson();
                }
            })
            .catch(error => {
                console.error("Loading error:", error);
                showError("Data load failed. Redirecting...");
                setTimeout(() => window.location.href = 'mainnightly.html', 2000);
            });
        });

            // Debug logging
            console.log('Initializing with:', {
                currentCode,
                basePath,
                lang,
                enabledQuestionTypes
            });

        function filterQuestionsByCode(pool, currentCode) {
            return pool.filter(item => {
                const itemParent = item.code.split('-')[0];
                const currentParent = currentCode.split('-')[0];
                return item.code === currentCode || itemParent === currentParent;
            });
        }

        // Cutscene handling
        function showCutscene(index) {
            if (index >= cutscenes.length) {
                endCutscene();
                return;
            }

            const scene = cutscenes[index];
            const container = document.getElementById('cutsceneContent');
            container.innerHTML = '';
            typeWriter(container, scene.lines, 0);
        }

        // Typewriter effect with click-to-skip
        function typeWriter(container, lines, lineIndex, charIndex = 0) {
            if (lineIndex >= lines.length) {
                container.parentElement.addEventListener('click', () => {
                    currentCutsceneIndex++;
                    showCutscene(currentCutsceneIndex);
                }, { once: true });
                return;
            }

            const lineDiv = document.createElement('div');
            lineDiv.className = 'cutscene-line';
            container.appendChild(lineDiv);

            const processChar = () => {
                if (charIndex < lines[lineIndex].length) {
                    lineDiv.textContent += lines[lineIndex][charIndex];
                    charIndex++;
                    setTimeout(processChar, 75); // 75ms per character
                } else {
                    lineIndex++;
                    charIndex = 0;
                    typeWriter(container, lines, lineIndex);
                }
            };

            // Force-complete on click
            const clickHandler = () => {
                if (charIndex < lines[lineIndex].length) {
                    lineDiv.textContent = lines[lineIndex];
                    charIndex = lines[lineIndex].length;
                } else {
                    currentCutsceneIndex++;
                    showCutscene(currentCutsceneIndex);
                }
            };

            container.parentElement.addEventListener('click', clickHandler, { once: true });
            processChar();
        }

        // End cutscene and transition to questions
        function endCutscene() {
            const cutsceneContainer = document.getElementById('cutsceneContainer');
            cutsceneContainer.classList.add('hidden');

            setTimeout(() => {
                cutsceneContainer.remove();
                startLesson();
            }, 500); // Match transition duration
        }

        // Lesson handling
        function startLesson() {
            document.getElementById('activity').classList.add('active');
            generateNextQuestion();
        }

        // Modified generateNextQuestion
        function generateNextQuestion() {
            window.isAnswered = false;
            disableButtons(true);
            
            try {
                if (questionsCompleted >= questionsPerLesson) {
                    completeLesson();
                    return;
                }

                // Validate pools
                const validatePool = (pool) => {
                    if (!Array.isArray(pool)) throw new Error('Invalid pool');
                    return pool.filter(q => q && (q.word || q.blank || q.audio));
                };

                let questionPool = [];
                    if(currentLesson.practicecirc) {
                        questionPool = [
                            ...validatePool(relearnType1),
                            ...validatePool(relearnType2)
                        ];
                    } else {
                        questionPool = [
                            ...(enabledQuestionTypes.includes('type1') ? validatePool(type1Data) : []),
                            ...(enabledQuestionTypes.includes('type2') ? validatePool(type2Data) : []),
                            ...(enabledQuestionTypes.includes('type3') ? validatePool(type3Data) : []),
                            ...(enabledQuestionTypes.includes('type4') ? validatePool(type4Data) : [])
                        ];
                        
                        if(currentLesson.relearnpool) {
                            const relearnPool = [
                                ...validatePool(relearnType1),
                                ...validatePool(relearnType2)
                            ];
                            questionPool = getQuestionMix(relearnPool, questionPool, 0.2);
                        }
                    }

                currentQuestion = getRandomQuestion(questionPool);
                if (!currentQuestion) throw new Error('No valid questions found');

                displayQuestion(currentQuestion);
                questionsCompleted++;
                updateProgress();
                disableButtons(false);
            } catch (error) {
                console.error('Question generation error:', error);
                showError("Question loading failed. Redirecting...");
                setTimeout(() => window.location.href = 'mainnightly.html', 2000);
            }
        }

        // New question mixing function
        function getQuestionMix(relearnPool, mainPool, ratio) {
            const mixedPool = [];
            const splitIndex = Math.floor(mainPool.length * (1 - ratio));
            
            mainPool.slice(0, splitIndex).forEach(q => mixedPool.push(q));
            relearnPool.forEach(q => mixedPool.push(q));
            mainPool.slice(splitIndex).forEach(q => mixedPool.push(q));
            
            return mixedPool.sort(() => Math.random() - 0.5);
        }

        function updateRelearnPoolWithNewQuestions() {
            const allLearned = [
                ...type1Data.filter(q => q.code === currentCode),
                ...type2Data.filter(q => q.code === currentCode)
            ];
            
            allLearned.forEach(question => {
                const targetPool = question.word ? relearnType1 : relearnType2;
                if (!targetPool.some(q => q.code === question.code && 
                    (q.word === question.word || q.blank === question.blank))) {
                    targetPool.push(question);
                }
            });
            
            localStorage.setItem(`relearnType1_${lang}`, JSON.stringify(relearnType1));
            localStorage.setItem(`relearnType2_${lang}`, JSON.stringify(relearnType2));
        }

        // Get a random question from a pool
        function getRandomQuestion(pool) {
            if (pool.length === 0) return null;
            return pool[Math.floor(Math.random() * pool.length)];
        }

        // Display question logic
        function displayQuestion(question) {
            const activity = document.getElementById('activity');
            activity.innerHTML = ''; // Clear previous content

            try {

            // For questions with audio, add an audio player container
            if (question.audio) {
                // Append audio player container if it doesn't exist
                if (!document.getElementById('audioPlayer')) {
                    const audioContainer = document.createElement('div');
                    audioContainer.id = 'audioPlayer';
                    activity.appendChild(audioContainer);
                }
                // Then set up the question content
                if (question.blocks) {
                    activity.innerHTML += generateType4Question(question);
                } else if (question.answers?.text) {
                    activity.innerHTML += generateType3Question(question);
                    // Delay dataset update until after DOM render
                    setTimeout(() => {
                        const optionsContainer = document.getElementById('type3Options');
                        if (optionsContainer) {
                            optionsContainer.dataset.answers = JSON.stringify(question.answers.text);
                        }
                    }, 0);
                }
                // Initialize audio using the updated base path (see next section)
                initAudioPlayer(question.audio);
            } else if (question.word) {
                activity.innerHTML = generateType1Question(question);
            } else if (question.blank) {
                activity.innerHTML = generateType2Question(question);
            } else {
                throw new Error('Invalid question type');
            }
            }catch (error) {
                    console.error('Question display error:', error);
                    if(error.message.includes('Invalid question type')) {
                        showError("Invalid question type for this course");
                        setTimeout(() => generateNextQuestion(), 1500);
                    } else {
                        throw error;
                    }
                }
        }

        // Audio Player Initialization
        function initAudioPlayer(audioPath) {
            const player = document.getElementById('audioPlayer');
            player.innerHTML = ''; // Clear previous audio player
            const container = document.createElement('div');
            container.className = 'audio-player-container';
            container.innerHTML = `
                <button onclick="playAudio('${audioPath}')">▶ Play Audio</button>
                <audio id="questionAudio" src="${basePath}audiofiles/${audioPath}"></audio>
            `;
            player.appendChild(container);
        }

        function playAudio(path) {
            const audio = new Audio(`${basePath}audiofiles/${path}`);
            audio.play();
        }

        // Generate Type 1 question
        function generateType1Question(question) {
            // Gather candidates from both pools (excluding the correct answer)
            let candidates = [
                ...type1Data.filter(q => q.word !== question.word),
                ...relearnType1.filter(q => q.word !== question.word)
            ];
            
            // Remove duplicates based on the word property
            let uniqueCandidates = candidates.filter((q, idx, self) =>
                idx === self.findIndex(t => t.word === q.word)
            );

            // Randomly decide total number of options (2, 3, or 4)
            let totalOptions = [2, 3, 4][Math.floor(Math.random() * 3)];
            // We need at least one wrong option (correct answer will be added later)
            let numWrong = totalOptions - 1;

            // Shuffle and slice wrong options; if not enough, take as many as available
            uniqueCandidates.sort(() => Math.random() - 0.5);
            let wrongOptions = uniqueCandidates.slice(0, numWrong);

            // Combine the correct answer with wrong options and shuffle them
            let options = [question, ...wrongOptions];
            options.sort(() => Math.random() - 0.5);

            return `
                <div class="question">Which word means "${question.translation}"?</div>
                <div class="options">
                    ${options.map(o => `
                        <button onclick="selectAnswer('${o.word}', '${question.word}')">
                            ${o.word}
                        </button>
                    `).join('')}
                </div>
            `;
        }

        // Generate Type 2 question
        function generateType2Question(question) {
            return `
                <div class="question">${question.sentence}</div>
                <p>${question.translation}</p>
                <input type="text" id="grammarAnswer" placeholder="Your answer" autocomplete="off">
                <button onclick="checkGrammarAnswer('${question.blank}')">Submit Answer</button>
            `;
        }

        // Type 3 Question Generation
        function generateType3Question(question) {
            // Determine the correct answer (we assume the first element in the text array is correct)
            const correctAnswer = question.answers.text[0];
            
            // Build a candidate pool for wrong answers from all Type 3 questions with the same code
            // (Using each question's 'answers.selection' array)
            let candidatePool = type3Data
                .filter(q => q.code === question.code && q !== question)
                .flatMap(q => q.answers.selection);
            
            // Remove duplicates and filter out the correct answer
            candidatePool = candidatePool.filter((a, index, self) =>
                self.indexOf(a) === index && a !== correctAnswer
            );
            
            // Randomly decide total number of options (2, 3, or 4)
            const totalOptions = [2, 3, 4][Math.floor(Math.random() * 3)];
            const numWrong = totalOptions - 1;
            
            // Shuffle candidate pool and pick wrong options (if not enough, take as many as available)
            candidatePool.sort(() => Math.random() - 0.5);
            const wrongOptions = candidatePool.slice(0, numWrong);
            
            // Combine correct answer with wrong options and shuffle final options
            let options = [correctAnswer, ...wrongOptions];
            options.sort(() => Math.random() - 0.5);
            
            // Build and return the Type 3 question HTML
            return `
                <div class="type3-question-container">
                    <div class="question">Which word did you hear?</div>
                    <div class="type3-options" id="type3Options">
                        ${options.map(opt => `
                            <button onclick="handleType3Answer('${opt.replace(/'/g, "\\'")}', ['${correctAnswer.replace(/'/g, "\\'")}'])">
                                ${opt}
                            </button>
                        `).join('')}
                    </div>
                    <div id="type3TextContainer" style="display: none; text-align: center; margin-top: 10px;">
                        <input type="text" id="type3TextInput" placeholder="Type your answer here" style="width: 300px; padding: 12px; font-size: 1.1rem; text-align: center;">
                        <button id="type3Submit" onclick="handleType3TextSubmit()" style="padding: 12px 24px;">Submit</button>
                    </div>
                    <div class="input-mode" id="type3InputContainer" style="text-align: center; margin-top: 10px;">
                        <select id="type3InputMode" onchange="updateType3InputMode()">
                            <option value="selection">Multiple Choice</option>
                            <option value="text">Type Answer</option>
                        </select>
                    </div>
                </div>
            `;
        }

        // Type 4 Question Generation
        function generateType4Question(question) {
            // Shuffle blocks before rendering
            const shuffledBlocks = shuffleArray([...question.blocks]);
            
            return `
                <div class="question">Build the sentence you heard:</div>
                <div class="input-mode-selector">
                    <select id="inputMode" onchange="toggleType4InputMode()">
                        <option value="blocks">Word Blocks</option>
                        <option value="text">Type Answer</option>
                    </select>
                </div>
                <!-- Blocks Mode -->
                <div id="blocksMode">
                    <div class="blocks-tray" id="initialTray">
                        ${shuffledBlocks.map(block => `
                            <div class="word-block" onclick="moveBlock(this)">${block}</div>
                        `).join('')}
                    </div>
                    <div class="sentence-builder" id="answerTray"></div>
                </div>
                <!-- Text Mode -->
                <div id="textMode" style="display: none;">
                    <input type="text" id="type4TextInput" placeholder="Type your answer here">
                </div>
                <button onclick="checkType4Answer()">Submit</button>
            `;
        }

        function handleType3Answer(selected, validAnswers) {
            if (window.isAnswered) return;
            window.isAnswered = true;
            
            // Normalize the selected answer and valid answers using wanakana
            const normalizedSelected = normalizeJapanese(selected);
            const normalizedAnswers = validAnswers.map(normalizeJapanese);
            const isCorrect = normalizedAnswers.includes(normalizedSelected);
            
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");
            
            // Optionally, clear or hide the audio player so it doesn't persist:
            const audioPlayerContainer = document.getElementById('audioPlayer');
            if (audioPlayerContainer) {
                audioPlayerContainer.innerHTML = '';
            }
            
            setTimeout(() => generateNextQuestion(), 1500);
        }

        function updateType3InputMode() {
            const mode = document.getElementById('type3InputMode').value;
            const optionsContainer = document.getElementById('type3Options');
            const textContainer = document.getElementById('type3TextContainer');
            
            if (mode === 'selection') {
                optionsContainer.style.display = 'flex';
                textContainer.style.display = 'none';
            } else {
                optionsContainer.style.display = 'none';
                textContainer.style.display = 'block';
            }
        }

        function handleType3Answer(selected, validAnswers) {
            if (window.isAnswered) return;
            const normalizedSelected = normalizeJapanese(selected);
            const normalizedAnswers = validAnswers.map(normalizeJapanese);
            const isCorrect = normalizedAnswers.includes(normalizedSelected);
            
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");
            setTimeout(() => generateNextQuestion(), 1500);
        }

        function handleType3TextSubmit() {
            const userAnswer = normalizeJapanese(document.getElementById('type3TextInput').value);
            const validAnswers = JSON.parse(document.getElementById('type3Options').dataset.answers);
            const isCorrect = validAnswers.some(a => normalizeJapanese(a) === userAnswer);
            
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");
            setTimeout(() => generateNextQuestion(), 1500);
        }

        // Japanese Normalization
        function normalizeJapanese(text) {
            return wanakana.toHiragana(
                text.normalize('NFKC')
                    .replace(/[！？。、・]/g, '')
                    .toLowerCase()
            );
        }




        function toggleType4InputMode() {
            const mode = document.getElementById('inputMode').value;
            document.getElementById('blocksMode').style.display = mode === 'blocks' ? 'block' : 'none';
            document.getElementById('textMode').style.display = mode === 'text' ? 'block' : 'none';
            
            if (mode === 'blocks') {
                resetBlockInterface();
            }
        }

        // Shuffle blocks initially
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Click-based block movement
        function moveBlock(block) {
            const isInAnswerTray = block.parentElement.id === 'answerTray';
            const targetTray = isInAnswerTray ? 
                document.getElementById('initialTray') : 
                document.getElementById('answerTray');

            // Clone block to preserve original in initial tray
            if (!isInAnswerTray) {
                const clone = block.cloneNode(true);
                clone.onclick = () => moveBlock(clone);
                targetTray.appendChild(clone);
            } else {
                block.remove();
            }
        }

        // Initialize blocks with random order
        function resetBlockInterface() {
            const initialTray = document.getElementById('initialTray');
            const blocks = Array.from(initialTray.children);
            shuffleArray(blocks).forEach(block => initialTray.appendChild(block));
        }

        // Drag-and-drop handlers (optional fallback)
        function handleDragStart(e) {
            e.dataTransfer.setData('text/plain', e.target.textContent);
        }

        function handleDrop(e) {
            e.preventDefault();
            const block = document.createElement('div');
            block.className = 'word-block';
            block.textContent = e.dataTransfer.getData('text/plain');
            block.onclick = () => moveBlock(block);
            e.target.appendChild(block);
        }

        // Initialize drag events
        function initDragAndDrop() {
        document.querySelectorAll('.word-block').forEach(block => {
            block.addEventListener('dragstart', handleDragStart);
        });
        
        document.querySelector('.sentence-builder').addEventListener('dragover', handleDragOver);
        document.querySelector('.sentence-builder').addEventListener('drop', handleDrop);
        }

        // Answer handling
        function selectAnswer(selected, correct) {
            if (window.isAnswered) return; // Prevent double-submission
            window.isAnswered = true;
            
            const isCorrect = selected === correct;
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");

            // Use currentQuestion directly
            if (currentQuestion && currentQuestion.word) {
                const targetPool = relearnType1;
                if (!targetPool.some(q => q.word === currentQuestion.word)) {
                    targetPool.push(currentQuestion);
                    localStorage.setItem(`relearnType1_${lang}`, JSON.stringify(targetPool));
                }
            }

            setTimeout(() => generateNextQuestion(), 1500);
        }

        function checkType4Answer() {
            if (window.isAnswered) return;
            window.isAnswered = true;

            const mode = document.getElementById('inputMode').value;
            let userAnswer;

            if (mode === 'blocks') {
                userAnswer = Array.from(document.querySelectorAll('#answerTray .word-block'))
                                .map(block => block.textContent.trim())
                                .join(' ');
            } else {
                userAnswer = document.getElementById('type4TextInput').value.trim();
            }

            const normalizedUser = normalizeJapanese(userAnswer);
            
            // Ensure correct comparison by removing spaces and normalizing
            const isValid = currentQuestion.possibleAnswers.some(answer => 
                normalizeJapanese(answer.replace(/\s+/g, '')) === normalizedUser.replace(/\s+/g, '')
            );

            showFeedback(isValid ? "Correct!" : "Incorrect!", isValid ? "correct" : "incorrect");
            setTimeout(generateNextQuestion, 1500);
        }

        // Add this Relearn Item structure
        const relearnItemStructure = {
            item: null,
            correctCount: 0,
            lastPracticed: null,
            practiceHistory: []
        };

        function checkGrammarAnswer() {
            if (window.isAnswered) return;
            window.isAnswered = true;
            
            const userInput = document.getElementById('grammarAnswer').value.trim();
            const normalizedUser = normalizeJapanese(userInput);
            
            // Handle array or string blank values
            const correctAnswers = Array.isArray(currentQuestion.blank) ? 
                currentQuestion.blank.map(normalizeJapanese) : 
                [normalizeJapanese(currentQuestion.blank)];
            
            const possibleAnswers = [
                ...correctAnswers,
                ...currentQuestion.possibleAnswers.map(normalizeJapanese)
            ];

            const isCorrect = possibleAnswers.some(a => a === normalizedUser);
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");

            setTimeout(() => generateNextQuestion(), 1500);
        }

        // New answer handling logic
        function handleCorrectAnswer(question) {
            const targetPool = question.word ? relearnType1 : relearnType2;
            const existing = targetPool.find(item => 
                item.code === question.code && 
                (item.word === question.word || item.blank === question.blank)
            );

            if (existing) {
                existing.correctCount = (existing.correctCount || 0) + 1;
                if (existing.correctCount >= (existing.pracrepetition || 3)) {
                    targetPool.splice(targetPool.indexOf(existing), 1);
                }
            }
            
            localStorage.setItem(question.word ? 'relearnType1' : 'relearnType2', 
                JSON.stringify(targetPool));
        }

        function disableButtons(state) {
            document.querySelectorAll('button').forEach(btn => btn.disabled = state);
            const answerInput = document.getElementById('grammarAnswer');
            if (answerInput) answerInput.disabled = state;
        }

        // Show feedback
        function showFeedback(message, className) {
            const feedback = document.createElement('div');
            feedback.className = `global-feedback ${className}`;
            feedback.innerHTML = `
                <span>${message}</span>
            `;
            document.body.appendChild(feedback);
            setTimeout(() => feedback.remove(), 1500);
        }

        // Add input mode toggle
        function createInputModeSelector() {
            const container = document.createElement('div');
            container.className = 'input-mode';
            
            container.innerHTML = `
                <label>
                    Input Mode:
                </label>
                <select id="inputMode">
                    <option value="type">Type Answer</option>
                    <option value="blocks">Word Blocks</option>
                </select>
            `;

            return container;
        }

        // Update progress bar
        function updateProgress() {
            const currentLesson = lessonProgress.find(lp => lp.code === currentCode);
            if (currentLesson) {
                const progress = (questionsCompleted / currentLesson.questionsPerLesson) * 100;
                document.getElementById('progressBar').style.width = `${progress}%`;
                
                // Update title and progress display
                document.title = `Livygo - ${currentLesson.title}`;
                const progressText = `${currentLesson.current}/${currentLesson.total}`;
                // Update your progress display element here
            }
        }

        // Complete lesson and update progress
        function completeLesson() {
            // Retrieve lesson progress from localStorage
            const storedProgress = JSON.parse(localStorage.getItem(`lessonProgress_${lang}`)) || [];
            const currentLesson = storedProgress.find(lp => lp.code === currentCode);

            if (currentLesson) {
                // Increase lesson count and save progress
                currentLesson.current = Math.min(currentLesson.current + 1, currentLesson.total);
                localStorage.setItem(`lessonProgress_${lang}`, JSON.stringify(storedProgress));
            }

            // Fade out and redirect back to main page
            document.body.classList.add('fade-out');
            setTimeout(() => window.location.href = 'mainnightly.html', 500);
        }
        
        // Show error message
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'global-error';
            errorDiv.innerHTML = `
                <h3>Error</h3>
                <p>${message}</p>
            `;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 3000);
        }
    </script>
    <script src="codeParser.js"></script>
</body>
</html>