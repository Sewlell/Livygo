<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Livygo - Question</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Poppins', sans-serif;
        }

        body {
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #f4f4f4;
            position: relative;
        }

        /* Progress Bar */
        .progress-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background-color: #eee;
            z-index: 999;
        }

        .progress-bar {
            height: 100%;
            background-color: #8B0000;
            transition: width 0.3s ease;
        }

        /* Cutscene Styling */
        .cutscene-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: white;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            opacity: 1;
            transition: opacity 0.5s ease;
        }

        .cutscene-container.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .cutscene-content {
            font-size: 2rem;
            text-align: center;
            max-width: 800px;
            line-height: 1.5;
            z-index: 1000; /* Ensure this is higher than activity */
            pointer-events: auto; /* Enable clicks */
        }

        .skip-indicator {
            position: absolute;
            bottom: 2rem;
            animation: pulse 1.5s infinite;
            opacity: 0.7;
            font-size: 1.2rem;
        }

        /* Activity Styling */
        .activity {
            text-align: center;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.5s ease;
            width: 90%;
            max-width: 600px;
            z-index: 1; /* Keep behind cutscene */
        }

        .activity.active {
            opacity: 1;
            transform: translateY(0);
        }

        /* Question Styling */
        .question {
            font-size: 1.5rem;
            margin-bottom: 2rem;
        }

        .options {
            display: grid;
            gap: 1rem;
            margin-bottom: 2rem;
        }

        button {
            padding: 1rem 2rem;
            border: none;
            border-radius: 8px;
            background-color: #4CAF50;
            color: white;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        button:hover {
            transform: translateY(-2px);
        }

        input {
            padding: 1rem;
            width: 100%;
            margin: 1rem 0;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1rem;
        }

        /* Error Styling */
        .global-error {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #ffebee;
            color: #b71c1c;
            padding: 1rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translate(-50%, -20px); }
            to { opacity: 1; transform: translate(-50%, 0); }
        }

        @keyframes pulse {
            0% { transform: translateY(0); opacity: 0.7; }
            50% { transform: translateY(-5px); opacity: 1; }
            100% { transform: translateY(0); opacity: 0.7; }
        }

        .global-feedback {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 1rem 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            z-index: 1000;
            animation: slideIn 0.3s ease, fadeOut 0.5s ease 1s;
            color: white;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .global-feedback.correct {
            background-color: #4CAF50;
            border: 2px solid #388E3C;
        }

        .global-feedback.incorrect {
            background-color: #d32f2f;
            border: 2px solid #b71c1c;
        }

        .global-feedback::before {
            content: '';
            display: inline-block;
            width: 24px;
            height: 24px;
            background-size: contain;
            background-repeat: no-repeat;
        }

        .global-feedback.correct::before {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>');
        }

        .global-feedback.incorrect::before {
            background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="white"><path d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>');
        }

        @keyframes slideIn {
            from { top: -50px; opacity: 0; }
            to { top: 20px; opacity: 1; }
        }

        @keyframes fadeOut {
            from { opacity: 1; }
            to { opacity: 0; }
        }

        /* Add warning feedback style */
        .global-feedback.warning {
            background-color: #FFC107;
            border: 2px solid #FFA000;
            color: #000;
        }

        .word-block {
            display: inline-block;
            min-width: auto;
            padding: 6px 10px;
            font-size: 1rem;
            background: #8B0000;
            color: white;
            border-radius: 4px;
            margin: 4px;
            cursor: pointer;
            text-align: center;
        }

        .blocks-tray {
            background: #f8f8f8;
            min-height: 60px;
            border-radius: 8px;
        }

        .sentence-builder {
            background: #fff;
            min-height: 80px;
            margin-top: 1rem;
            border-radius: 8px;
            border: 2px dashed #ccc;
        }

        .blocks-tray, .sentence-builder {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 1rem;
        }

        .answer-area {
            min-height: 60px;
            border: 2px dashed #ccc;
            margin: 1rem 0;
        }

        .input-mode {
            margin-top: 1rem;
            padding: 1rem;
            background: #f8f8f8;
            border-radius: 8px;
            min-height: 80px;
        }

        .audio-player-container {
            text-align: center;
            margin: 1rem 0;
        }

        #type3InputContainer {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        #type3TextInput {
            width: 300px;
            padding: 12px;
            font-size: 1.1rem;
            margin: 0.5rem 0;
        }

        #type3Submit {
            padding: 12px 24px;
            width: fit-content;
            margin: 0.5rem 0;
        }

        .type3-question-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 1rem;
        }

        .type3-options {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin: 1rem 0;
        }

        #textContainer input {
            width: 100%;
            max-width: 500px;
            padding: 12px;
            font-size: 1.1rem;
        }

        .kanji-container {
            max-width: 600px;
            margin: 2rem auto;
            text-align: center;
        }

        .writing-area {
            position: relative;
            width: 300px;
            height: 300px;
            margin: 1rem auto;
            border: 2px solid #8B0000;
            border-radius: 8px;
        }

        #kanjiCanvas {
            position: absolute;
            top: 0;
            left: 0;
            z-index: 2;
        }

        .grid-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: linear-gradient(to right, #acacac 1px, transparent 1px),
                            linear-gradient(to bottom, #acacac 1px, transparent 1px);
            background-size: 30px 30px;
            z-index: 1;
        }

        .kanji-controls {
            margin-top: 1rem;
            display: flex;
            gap: 1rem;
            justify-content: center;
        }

        .ocr-settings {
            margin: 1rem 0;
            color: #666;
        }

        .kanji-controls button:disabled {
            background-color: #cccccc !important;
            transform: none !important;
            pointer-events: none !important;
        }
    </style>
</head>
<body>
    <div class="progress-container">
        <div class="progress-bar" id="progressBar"></div>
    </div>

    <div class="cutscene-container" id="cutsceneContainer">
        <div class="cutscene-content" id="cutsceneContent"></div>
        <div class="skip-indicator">▼ Click to continue ▼</div>
    </div>

    <div class="activity" id="activity"></div>

    <script src="https://unpkg.com/wanakana@5.3.1/wanakana.min.js"></script>
    <script>
        // Configuration
        const urlParams = new URLSearchParams(window.location.search);
        const currentCode = urlParams.get('code') || '001001';
        const basePath = urlParams.get('basePath') || '/courses/ES-en/General/001/';
        const lang = urlParams.get('lang') || 'ES-en';
        const subcourse = urlParams.get('subcourse') || 'General';

        // New path construction
        const sectionCode = currentCode.substring(0, 3);
        const dynamicBasePath = `/courses/${lang}/${subcourse}/${sectionCode}/`;
        
        let questionsPerLesson = 5;
        let questionsCompleted = 0;
        let currentCutsceneIndex = 0;
        let cutscenes = [];
        let isCutsceneActive = false;
        let currentQuestion = null;

        // Data storage
        let type1Data = [];
        let type2Data = [];
        let type3Data = [];
        let type4Data = [];
        let type6Data = [];
        let enableOCR = true;
        let enabledQuestionTypes = ['type1', 'type2', 'type3', 'type4'];
        let relearnType1 = JSON.parse(localStorage.getItem(`relearnType1_${lang}`)) || [];
        let relearnType2 = JSON.parse(localStorage.getItem(`relearnType2_${lang}`)) || [];
        let lessonProgress = {};
        let currentLesson = null;

        // Type 6 stuff
        let strokes = [];
        let isDrawing = false;
        let canvas, ctx;
        let isHandwriteLocked = false;
        let currentTimeout = null;
        let requiredStrokeAccuracy = 75;

        document.addEventListener('DOMContentLoaded', () => {
            const storedProgress = JSON.parse(localStorage.getItem(`lessonProgress_${lang}`)) || [];
            lessonProgress = storedProgress;
            requiredStrokeAccuracy = currentLesson?.settings?.requiredStrokeAccuracy || 75;

            // Load pathway structure first
            fetch(`/courses/${lang}/${subcourse}/pathway_structure.json`)
            .then(response => response.json())
            .then(pathwayStructure => {
                // Find the current section
                const numericCode = parseInt(currentCode);
                const section = pathwayStructure.find(s => 
                    s.addressMap.some(range => 
                        numericCode >= range.rangeStart && 
                        numericCode <= range.rangeEnd
                    )
                );

                const currentCircle = pathwayStructure.find(s => 
                    s.addressMap.some(range => 
                        numericCode >= range.rangeStart && 
                        numericCode <= range.rangeEnd
                    )
                );


                
                // Set enabled question types
                if(section?.settings?.enabledQuestionTypes) {
                    enabledQuestionTypes = section.settings.enabledQuestionTypes;
                }

                // Load other resources
                return Promise.all([
                    fetch(`${dynamicBasePath}lesson_progress.json`).then(res => res.json()),
                    fetch(`${dynamicBasePath}cutscenes.json`).then(res => res.json()),
                    enabledQuestionTypes.includes('type1') ? 
                        fetch(`${dynamicBasePath}type1_vocabulary.json`).then(res => res.json()) : 
                        Promise.resolve([]),
                    enabledQuestionTypes.includes('type2') ? 
                        fetch(`${dynamicBasePath}type2_grammar.json`).then(res => res.json()) : 
                        Promise.resolve([]),
                    enabledQuestionTypes.includes('type3') ? 
                        fetch(`${dynamicBasePath}type3_listening.json`).then(res => res.json()) : 
                        Promise.resolve([]),
                    enabledQuestionTypes.includes('type4') ? 
                        fetch(`${dynamicBasePath}type4_sentence.json`).then(res => res.json()) : 
                        Promise.resolve([]),
                    enabledQuestionTypes.includes('type6') ? 
                        fetch(`${dynamicBasePath}type6_characters.json`)
                            .then(res => res.json())
                            .then(data => {
                            // Extract circle code from currentCode (e.g. "001004" from "KAN-001004")
                            const circleCode = currentCode.split('-')[0];
                            return data.filter(q => 
                                q.guidcode.startsWith('KAN-') && 
                                q.guidcode.split('-')[1] === circleCode
                            );
                            }) : 
                        Promise.resolve([])
                ]);
            })
            .then(([progressData, cutsceneData, vocab, grammar, listening, sentence, type6]) => {
                type6Data = type6 || [];
                // Ensure progressData is array
                if (!Array.isArray(progressData)) {
                    progressData = [];
                }

                // Find or create current lesson
                currentLesson = storedProgress.find(lp => lp.code === currentCode) || 
                            progressData.find(p => p.code === currentCode) || 
                            progressData.find(p => p.code === 'default') || {
                                code: currentCode,
                                title: 'Default Title',
                                total: 5,
                                current: 1,
                                questionsPerLesson: 10,
                                practicecirc: false,
                                relearnpool: true
                            };

                // Update questionsPerLesson
                questionsPerLesson = currentLesson.questionsPerLesson || 10;
                
                // Store updated progress
                if (!storedProgress.some(lp => lp.code === currentCode)) {
                    storedProgress.push(currentLesson);
                    localStorage.setItem(`lessonProgress_${lang}`, JSON.stringify(storedProgress));
                }

                // Filter questions
                const baseCode = currentCode.split('-')[0];
                type1Data = enabledQuestionTypes.includes('type1') ? 
                    vocab.filter(item => 
                        item.code.startsWith(baseCode) && 
                        CodeParser.compare(item.code, currentLesson.praclimit || '')
                    ) : [];
                
                type2Data = enabledQuestionTypes.includes('type2') ? 
                    grammar.filter(item => 
                        item.code.startsWith(baseCode) && 
                        CodeParser.compare(item.code, currentLesson.praclimit || '')
                    ) : [];

                type3Data = enabledQuestionTypes.includes('type3') ? 
                    listening.filter(item =>
                        item.code.startsWith(baseCode) &&
                        CodeParser.compare(item.code, currentLesson.praclimit || '',
                        q => q.answers?.text && Array.isArray(q.answers.text))
                    ) : [];

                type4Data = enabledQuestionTypes.includes('type4') ? 
                    sentence.filter(item =>
                        item.code.startsWith(baseCode) &&
                        CodeParser.compare(item.code, currentLesson.praclimit || '',
                        q => q.blocks && Array.isArray(q.blocks))
                    ) : [];

                // Handle cutscenes
                const currentCutscene = cutsceneData.find(c => c.code === currentCode);
                if (currentCutscene?.nocutsc) {
                    document.getElementById('cutsceneContainer').remove();
                    startLesson();
                } else if (currentCutscene?.sequence) {
                    cutscenes = currentCutscene.sequence.flatMap(scene => 
                        scene.lines.join('\n').split(/\/{3,}/).map(part => ({
                            lines: part.trim().split('\n')
                        }))
                    );
                    showCutscene(0);
                } else {
                    document.getElementById('cutsceneContainer').remove();
                    startLesson();
                }
            })
            .catch(error => {
                console.error("Loading error:", error);
                showError("Data load failed. Redirecting...");
                setTimeout(() => window.location.href = 'mainnightly.html', 2000);
            });
        });

            // Debug logging
            console.log('Initializing with:', {
                currentCode,
                basePath,
                lang,
                enabledQuestionTypes,
            });

        function filterQuestionsByCode(pool, currentCode) {
            return pool.filter(item => {
                const itemParent = item.code.split('-')[0];
                const currentParent = currentCode.split('-')[0];
                return item.code === currentCode || itemParent === currentParent;
            });
        }

        // Cutscene handling
        function showCutscene(index) {
            if (index >= cutscenes.length) {
                endCutscene();
                return;
            }

            const scene = cutscenes[index];
            const container = document.getElementById('cutsceneContent');
            container.innerHTML = '';
            typeWriter(container, scene.lines, 0);
        }

        // Typewriter effect with click-to-skip
        function typeWriter(container, lines, lineIndex, charIndex = 0) {
            if (lineIndex >= lines.length) {
                container.parentElement.addEventListener('click', () => {
                    currentCutsceneIndex++;
                    showCutscene(currentCutsceneIndex);
                }, { once: true });
                return;
            }

            const lineDiv = document.createElement('div');
            lineDiv.className = 'cutscene-line';
            container.appendChild(lineDiv);

            const processChar = () => {
                if (charIndex < lines[lineIndex].length) {
                    lineDiv.textContent += lines[lineIndex][charIndex];
                    charIndex++;
                    setTimeout(processChar, 75); // 75ms per character
                } else {
                    lineIndex++;
                    charIndex = 0;
                    typeWriter(container, lines, lineIndex);
                }
            };

            // Force-complete on click
            const clickHandler = () => {
                if (charIndex < lines[lineIndex].length) {
                    lineDiv.textContent = lines[lineIndex];
                    charIndex = lines[lineIndex].length;
                } else {
                    currentCutsceneIndex++;
                    showCutscene(currentCutsceneIndex);
                }
            };

            container.parentElement.addEventListener('click', clickHandler, { once: true });
            processChar();
        }

        // End cutscene and transition to questions
        function endCutscene() {
            const cutsceneContainer = document.getElementById('cutsceneContainer');
            cutsceneContainer.classList.add('hidden');

            setTimeout(() => {
                cutsceneContainer.remove();
                startLesson();
            }, 500); // Match transition duration
        }









        // Lesson handling
        function startLesson() {
            document.getElementById('activity').classList.add('active');
            generateNextQuestion();
        }

        // Modified generateNextQuestion
        function generateNextQuestion() {
            window.isAnswered = false;
            disableButtons(true);
            
            try {
                if (questionsCompleted >= questionsPerLesson) {
                    completeLesson();
                    return;
                }

                // Validate pools
                const validatePool = (pool) => {
                    if (!Array.isArray(pool)) throw new Error('Invalid pool');
                    return pool.filter(q => q && (q.word || q.blank || q.audio || q.kanji));
                };

                let questionPool = [];
                    if(currentLesson.practicecirc) {
                        questionPool = [
                            ...validatePool(relearnType1),
                            ...validatePool(relearnType2)
                        ];
                    } else {
                        questionPool = [
                            ...(enabledQuestionTypes.includes('type1') ? validatePool(type1Data) : []),
                            ...(enabledQuestionTypes.includes('type2') ? validatePool(type2Data) : []),
                            ...(enabledQuestionTypes.includes('type3') ? validatePool(type3Data) : []),
                            ...(enabledQuestionTypes.includes('type4') ? validatePool(type4Data) : []),
                            ...(enabledQuestionTypes.includes('type6') ? validatePool(type6Data) : [])
                        ];
                        
                        if(currentLesson.relearnpool) {
                            const relearnPool = [
                                ...validatePool(relearnType1),
                                ...validatePool(relearnType2)
                            ];
                            questionPool = getQuestionMix(relearnPool, questionPool, 0.2);
                        }
                    }

                currentQuestion = getRandomQuestion(questionPool);
                if (!currentQuestion) throw new Error('No valid questions found');

                displayQuestion(currentQuestion);
                questionsCompleted++;
                updateProgress();
                disableButtons(false);
            } catch (error) {
                console.error('Question generation error:', error);
                showError("Question loading failed. Redirecting...");
                setTimeout(() => window.location.href = 'mainnightly.html', 2000);
            }
        }

        // New question mixing function
        function getQuestionMix(relearnPool, mainPool, ratio) {
            const mixedPool = [];
            const splitIndex = Math.floor(mainPool.length * (1 - ratio));
            
            mainPool.slice(0, splitIndex).forEach(q => mixedPool.push(q));
            relearnPool.forEach(q => mixedPool.push(q));
            mainPool.slice(splitIndex).forEach(q => mixedPool.push(q));
            
            return mixedPool.sort(() => Math.random() - 0.5);
        }

        function updateRelearnPoolWithNewQuestions() {
            const allLearned = [
                ...type1Data.filter(q => q.code === currentCode),
                ...type2Data.filter(q => q.code === currentCode)
            ];
            
            allLearned.forEach(question => {
                const targetPool = question.word ? relearnType1 : relearnType2;
                if (!targetPool.some(q => q.code === question.code && 
                    (q.word === question.word || q.blank === question.blank))) {
                    targetPool.push(question);
                }
            });
            
            localStorage.setItem(`relearnType1_${lang}`, JSON.stringify(relearnType1));
            localStorage.setItem(`relearnType2_${lang}`, JSON.stringify(relearnType2));
        }

        // Get a random question from a pool
        function getRandomQuestion(pool) {
            if (pool.length === 0) return null;
            return pool[Math.floor(Math.random() * pool.length)];
        }

        // Display question logic
        function displayQuestion(question) {
            const activity = document.getElementById('activity');
            activity.innerHTML = ''; // Clear previous content

            try {
                if (question.kanji) {
                    activity.innerHTML = generateType6Question(question);
                    setTimeout(initCanvas, 50);
                } else if (question.audio) {
                    // Append audio player container if it doesn't exist
                    if (!document.getElementById('audioPlayer')) {
                        const audioContainer = document.createElement('div');
                        audioContainer.id = 'audioPlayer';
                        activity.appendChild(audioContainer);
                    }
                    if (question.blocks) {
                        activity.innerHTML += generateType4Question(question);
                    } else if (question.answers?.text) {
                        activity.innerHTML += generateType3Question(question);
                        setTimeout(() => {
                            const optionsContainer = document.getElementById('type3Options');
                            if (optionsContainer) {
                                optionsContainer.dataset.answers = JSON.stringify(question.answers.text);
                            }
                        }, 0);
                    }
                    initAudioPlayer(question.audio);
                } else if (question.word) {
                    activity.innerHTML = generateType1Question(question);
                } else if (question.blank) {
                    activity.innerHTML = generateType2Question(question);
                } else {
                    throw new Error('Invalid question type');
                }
            } catch (error) {
                console.error('Question display error:', error);
                if (error.message.includes('Invalid question type')) {
                    showError("Invalid question type for this course");
                    setTimeout(() => generateNextQuestion(), 1500);
                } else {
                    throw error;
                }
            }
        }

        // Audio Player Initialization
        function initAudioPlayer(audioPath) {
            const container = document.createElement('div');
            container.className = 'audio-player-container';
            container.innerHTML = `
                <button onclick="playAudio('${audioPath}')">▶ Play Audio</button>
                <audio src="${dynamicBasePath}audiofiles/${audioPath}"></audio>
            `;
            document.getElementById('activity').appendChild(container);
        }

        function playAudio(path) {
            const audio = new Audio(`${dynamicBasePath}audiofiles/${path}`);
            audio.play();
        }

        // Generate Type 1 question
        function generateType1Question(question) {
            // Gather candidates from both pools (excluding the correct answer)
            let candidates = [
                ...type1Data.filter(q => q.word !== question.word),
                ...relearnType1.filter(q => q.word !== question.word)
            ];
            
            // Remove duplicates based on the word property
            let uniqueCandidates = candidates.filter((q, idx, self) =>
                idx === self.findIndex(t => t.word === q.word)
            );

            // Randomly decide total number of options (2, 3, or 4)
            let totalOptions = [2, 3, 4][Math.floor(Math.random() * 3)];
            // We need at least one wrong option (correct answer will be added later)
            let numWrong = totalOptions - 1;

            // Shuffle and slice wrong options; if not enough, take as many as available
            uniqueCandidates.sort(() => Math.random() - 0.5);
            let wrongOptions = uniqueCandidates.slice(0, numWrong);

            // Combine the correct answer with wrong options and shuffle them
            let options = [question, ...wrongOptions];
            options.sort(() => Math.random() - 0.5);

            return `
                <div class="question">Which word means "${question.translation}"?</div>
                <div class="options">
                    ${options.map(o => `
                        <button onclick="selectAnswer('${o.word}', '${question.word}')">
                            ${o.word}
                        </button>
                    `).join('')}
                </div>
            `;
        }

        // Generate Type 2 question
        function generateType2Question(question) {
            return `
                <div class="question">${question.sentence}</div>
                <p>${question.translation}</p>
                <input type="text" id="grammarAnswer" placeholder="Your answer" autocomplete="off">
                <button onclick="checkGrammarAnswer('${question.blank}')">Submit Answer</button>
            `;
        }

        // Type 3 Question Generation
        function generateType3Question(question) {
            // Determine the correct answer (we assume the first element in the text array is correct)
            const correctAnswer = question.answers.text[0];
            
            // Build a candidate pool for wrong answers from all Type 3 questions with the same code
            // (Using each question's 'answers.selection' array)
            let candidatePool = type3Data
                .filter(q => q.code === question.code && q !== question)
                .flatMap(q => q.answers.selection);
            
            // Remove duplicates and filter out the correct answer
            candidatePool = candidatePool.filter((a, index, self) =>
                self.indexOf(a) === index && a !== correctAnswer
            );
            
            // Randomly decide total number of options (2, 3, or 4)
            const totalOptions = [2, 3, 4][Math.floor(Math.random() * 3)];
            const numWrong = totalOptions - 1;
            
            // Shuffle candidate pool and pick wrong options (if not enough, take as many as available)
            candidatePool.sort(() => Math.random() - 0.5);
            const wrongOptions = candidatePool.slice(0, numWrong);
            
            // Combine correct answer with wrong options and shuffle final options
            let options = [correctAnswer, ...wrongOptions];
            options.sort(() => Math.random() - 0.5);
            
            // Build and return the Type 3 question HTML
            return `
                <div class="type3-question-container">
                    <div class="question">Which word did you hear?</div>
                    <div class="type3-options" id="type3Options">
                        ${options.map(opt => `
                            <button onclick="handleType3Answer('${opt.replace(/'/g, "\\'")}', ['${correctAnswer.replace(/'/g, "\\'")}'])">
                                ${opt}
                            </button>
                        `).join('')}
                    </div>
                    <div id="type3TextContainer" style="display: none; text-align: center; margin-top: 10px;">
                        <input type="text" id="type3TextInput" placeholder="Type your answer here" style="width: 300px; padding: 12px; font-size: 1.1rem; text-align: center;" autocomplete="off">
                        <button id="type3Submit" onclick="handleType3TextSubmit()" style="padding: 12px 24px;">Submit</button>
                    </div>
                    <div class="input-mode" id="type3InputContainer" style="text-align: center; margin-top: 10px;">
                        <select id="type3InputMode" onchange="updateType3InputMode()">
                            <option value="selection">Multiple Choice</option>
                            <option value="text">Type Answer</option>
                        </select>
                    </div>
                </div>
            `;
        }

        // Type 4 Question Generation
        function generateType4Question(question) {
            // Shuffle blocks before rendering
            const shuffledBlocks = shuffleArray([...question.blocks]);
            
            return `
                <div class="question">Build the sentence you heard:</div>
                <div class="input-mode-selector">
                    <select id="inputMode" onchange="toggleType4InputMode()">
                        <option value="blocks">Word Blocks</option>
                        <option value="text">Type Answer</option>
                    </select>
                </div>
                <!-- Blocks Mode -->
                <div id="blocksMode">
                    <div class="blocks-tray" id="initialTray">
                        ${shuffledBlocks.map(block => `
                            <div class="word-block" onclick="moveBlock(this)">${block}</div>
                        `).join('')}
                    </div>
                    <div class="sentence-builder" id="answerTray"></div>
                </div>
                <!-- Text Mode -->
                <div id="textMode" style="display: none;">
                    <input type="text" id="type4TextInput" placeholder="Type your answer here" autocomplete="off">
                </div>
                <button onclick="checkType4Answer()">Submit</button>
            `;
        }

        // Type 5 in the future....


        // Type 6 Question Generation
        function generateType6Question(question) {
            return `
                <div class="kanji-container">
                    <div class="kanji-prompt">Write this character in the box: ${question.kanji}</div>
                    <div class="writing-area">
                        <canvas id="kanjiCanvas"></canvas>
                        <div class="grid-overlay"></div>
                    </div>
                    <div class="ocr-settings">
                        <label>
                            <input type="checkbox" id="ocrToggle" ${enableOCR ? 'checked' : ''}>
                            Enable OCR Validation
                        </label>
                    </div>
                    <div class="kanji-controls">
                        <button onclick="resetCanvas()">↻ Reset</button>
                        <button onclick="validateKanji('${question.kanji}')">✓ Submit</button>
                    </div>
                </div>
            `;
        }

        function handleType3Answer(selected, validAnswers) {
            if (window.isAnswered) return;
            window.isAnswered = true;
            disableButtons(true);
            
            // Normalize the selected answer and valid answers using wanakana
            const normalizedSelected = normalizeJapanese(selected);
            const normalizedAnswers = validAnswers.map(normalizeJapanese);
            const isCorrect = normalizedAnswers.includes(normalizedSelected);
            
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");
            
            // Optionally, clear or hide the audio player so it doesn't persist:
            const audioPlayerContainer = document.getElementById('audioPlayer');
            if (audioPlayerContainer) {
                audioPlayerContainer.innerHTML = '';
            }
            
            setTimeout(() => generateNextQuestion(), 1500);
        }

        function updateType3InputMode() {
            const mode = document.getElementById('type3InputMode').value;
            const optionsContainer = document.getElementById('type3Options');
            const textContainer = document.getElementById('type3TextContainer');
            
            if (mode === 'selection') {
                optionsContainer.style.display = 'flex';
                textContainer.style.display = 'none';
            } else {
                optionsContainer.style.display = 'none';
                textContainer.style.display = 'block';
            }
        }

        function handleType3Answer(selected, validAnswers) {
            if (window.isAnswered) return;
            window.isAnswered = true;
            disableButtons(true);
            
            const normalizedSelected = normalizeJapanese(selected);
            const normalizedAnswers = validAnswers.map(normalizeJapanese);
            const isCorrect = normalizedAnswers.includes(normalizedSelected);
            
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");
            setTimeout(() => generateNextQuestion(), 1500);
        }

        function handleType3TextSubmit() {
            if (window.isAnswered) return;
            window.isAnswered = true;
            disableButtons(true);
            const userAnswer = normalizeJapanese(document.getElementById('type3TextInput').value);
            const validAnswers = JSON.parse(document.getElementById('type3Options').dataset.answers);
            const isCorrect = validAnswers.some(a => normalizeJapanese(a) === userAnswer);
            
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");
            setTimeout(() => generateNextQuestion(), 1500);
        }

        // Japanese Normalization
        function normalizeJapanese(text) {
            return wanakana.toHiragana(
                text.normalize('NFKC')
                    .replace(/[！？。、・]/g, '')
                    .toLowerCase()
            );
        }




        function toggleType4InputMode() {
            const mode = document.getElementById('inputMode').value;
            document.getElementById('blocksMode').style.display = mode === 'blocks' ? 'block' : 'none';
            document.getElementById('textMode').style.display = mode === 'text' ? 'block' : 'none';
            
            if (mode === 'blocks') {
                resetBlockInterface();
            }
        }

        // Shuffle blocks initially
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        // Click-based block movement
        function moveBlock(block) {
            const isInAnswerTray = block.parentElement.id === 'answerTray';
            const targetTray = isInAnswerTray ? 
                document.getElementById('initialTray') : 
                document.getElementById('answerTray');

            // Clone block to preserve original in initial tray
            if (!isInAnswerTray) {
                const clone = block.cloneNode(true);
                clone.onclick = () => moveBlock(clone);
                targetTray.appendChild(clone);
            } else {
                block.remove();
            }
        }

        // Initialize blocks with random order
        function resetBlockInterface() {
            const initialTray = document.getElementById('initialTray');
            const blocks = Array.from(initialTray.children);
            shuffleArray(blocks).forEach(block => initialTray.appendChild(block));
        }

        // Answer handling
        function selectAnswer(selected, correct) {
            if (window.isAnswered) return; // Prevent double-submission
            window.isAnswered = true;
            
            const isCorrect = selected === correct;
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");

            // Use currentQuestion directly
            if (currentQuestion && currentQuestion.word) {
                const targetPool = relearnType1;
                if (!targetPool.some(q => q.word === currentQuestion.word)) {
                    targetPool.push(currentQuestion);
                    localStorage.setItem(`relearnType1_${lang}`, JSON.stringify(targetPool));
                }
            }

            setTimeout(() => generateNextQuestion(), 1500);
        }

        function checkType4Answer() {
            if (window.isAnswered) return;
            window.isAnswered = true;

            const mode = document.getElementById('inputMode').value;
            let userAnswer;

            if (mode === 'blocks') {
                userAnswer = Array.from(document.querySelectorAll('#answerTray .word-block'))
                                .map(block => block.textContent.trim())
                                .join(' ');
            } else {
                userAnswer = document.getElementById('type4TextInput').value.trim();
            }

            const normalizedUser = normalizeJapanese(userAnswer);
            
            // Ensure correct comparison by removing spaces and normalizing
            const isValid = currentQuestion.possibleAnswers.some(answer => 
                normalizeJapanese(answer.replace(/\s+/g, '')) === normalizedUser.replace(/\s+/g, '')
            );

            showFeedback(isValid ? "Correct!" : "Incorrect!", isValid ? "correct" : "incorrect");
            setTimeout(generateNextQuestion, 1500);
        }

        // Add this Relearn Item structure
        const relearnItemStructure = {
            item: null,
            correctCount: 0,
            lastPracticed: null,
            practiceHistory: []
        };

        function checkGrammarAnswer() {
            if (window.isAnswered) return;
            window.isAnswered = true;
            
            const userInput = document.getElementById('grammarAnswer').value.trim();
            const normalizedUser = normalizeJapanese(userInput);
            
            // Handle array or string blank values
            const correctAnswers = Array.isArray(currentQuestion.blank) ? 
                currentQuestion.blank.map(normalizeJapanese) : 
                [normalizeJapanese(currentQuestion.blank)];
            
            const possibleAnswers = [
                ...correctAnswers,
                ...currentQuestion.possibleAnswers.map(normalizeJapanese)
            ];

            const isCorrect = possibleAnswers.some(a => a === normalizedUser);
            showFeedback(isCorrect ? "Correct!" : "Incorrect!", isCorrect ? "correct" : "incorrect");

            setTimeout(() => generateNextQuestion(), 1500);
        }

        // New answer handling logic
        function handleCorrectAnswer(question) {
            const targetPool = question.word ? relearnType1 : relearnType2;
            const existing = targetPool.find(item => 
                item.code === question.code && 
                (item.word === question.word || item.blank === question.blank)
            );

            if (existing) {
                existing.correctCount = (existing.correctCount || 0) + 1;
                if (existing.correctCount >= (existing.pracrepetition || 3)) {
                    targetPool.splice(targetPool.indexOf(existing), 1);
                }
            }
            
            localStorage.setItem(question.word ? 'relearnType1' : 'relearnType2', 
                JSON.stringify(targetPool));
        }

        function disableButtons(state) {
            document.querySelectorAll('button').forEach(btn => btn.disabled = state);
            const answerInput = document.getElementById('grammarAnswer');
            if (answerInput) answerInput.disabled = state;
        }

        // Show feedback
        function showFeedback(message, className) {
            const feedback = document.createElement('div');
            feedback.className = `global-feedback ${className}`;
            feedback.innerHTML = `
                <span>${message}</span>
            `;
            document.body.appendChild(feedback);
            setTimeout(() => feedback.remove(), 1500);
        }

        // Add input mode toggle
        function createInputModeSelector() {
            const container = document.createElement('div');
            container.className = 'input-mode';
            
            container.innerHTML = `
                <label>
                    Input Mode:
                </label>
                <select id="inputMode">
                    <option value="type">Type Answer</option>
                    <option value="blocks">Word Blocks</option>
                </select>
            `;

            return container;
        }












        // getHandwritingConfig used to be for KanjiVG initialization. I think it will be useful once OCR adaped.

        //function getHandwritingConfig() {
        //    const baseConfig = {
        //        "6a": { // Simplified Chinese
        //        model: "zh_sim",
        //        strokeTolerance: 0.2,
        //       radicalValidation: true
        //        },
        //        "6b": { // Traditional Chinese
        //        model: "zh_tra",
        //        strokeTolerance: 0.25,
        //        allowVariants: true
        //        },
        //        "6c": { // Japanese Kanji
        //        model: "ja_kanji",
        //        strokeTolerance: 0.3,
        //        jōyōOnly: true
        //        }
        //    };
        //    
        //    return currentCircle.settings?.handwritecirc?.subtypes?.reduce((acc, subtype) => {
        //        return {...acc, ...baseConfig[subtype]};
        //    }, {});
        //}

        function initCanvas() {
            strokes = [];
            canvas = document.getElementById('kanjiCanvas');
            ctx = canvas.getContext('2d');
            
            canvas.width = 300;
            canvas.height = 300;
            
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';
            ctx.strokeStyle = '#8B0000';

            // Event listeners for mouse
            canvas.addEventListener('mousedown', startStroke);
            canvas.addEventListener('mousemove', drawStroke);
            canvas.addEventListener('mouseup', endStroke);
            canvas.addEventListener('mouseleave', endStroke); // Stop drawing when leaving the canvas

            // Event listeners for touch
            canvas.addEventListener('touchstart', startStroke);
            canvas.addEventListener('touchmove', drawStroke);
            canvas.addEventListener('touchend', endStroke);
        }

        function startStroke(e) {
            isDrawing = true;
            strokes.push([]);
            const pos = getCanvasPosition(e);
            ctx.beginPath();
            ctx.moveTo(pos.x, pos.y);
        }

        function drawStroke(e) {
            if (!isDrawing) return;
            const pos = getCanvasPosition(e);
            if (!pos) return; // In case position cannot be determined

            const currentStroke = strokes[strokes.length - 1];
            // Safeguard: if currentStroke is not defined, stop drawing
            if (!currentStroke) return;

            currentStroke.push({
                x: pos.x,
                y: pos.y,
                t: Date.now()
            });

            ctx.lineTo(pos.x, pos.y);
            ctx.stroke();
        }

        function endStroke() {
            isDrawing = false;
            ctx.closePath();
        }

        function getCanvasPosition(e) {
            const rect = canvas.getBoundingClientRect();
            return {
                x: (e.clientX || e.touches[0].clientX) - rect.left,
                y: (e.clientY || e.touches[0].clientY) - rect.top
            };
        }

        async function validateKanji(expected) {
            if (window.isAnswered || isHandwriteLocked) return;

            try {
                window.isAnswered = true;
                disableHandwriteControls(true);

                const kanjiData = type6Data.find(k => k.kanji === expected);
                if (!kanjiData) throw new Error('Kanji not found');

                // Validate stroke count first
                if (strokes.length !== kanjiData.strokes) {
                    showFeedback("Stroke count mismatch!", "warning");
                    resetValidationState();
                    return;
                }

                // Calculate accuracy
                const accuracy = await validateStrokeOrder(strokes, kanjiData);

                // Use required accuracy from kanji data if available,
                // otherwise from currentLesson settings, or default to 75.
                let requiredAccuracy = currentLesson?.settings?.requiredStrokeAccuracy || 75;
                if (requiredAccuracy < 1) {
                    requiredAccuracy *= 100;
                }

                console.log(`Accuracy: ${accuracy}% (Required: ${requiredAccuracy}%)`);

                // Enforce strict accuracy threshold using requiredAccuracy
                if (accuracy >= requiredAccuracy) {
                    isHandwriteLocked = true;
                    showFeedback(`Correct! (${accuracy.toFixed(2)}%)`, "correct");
                    setTimeout(() => {
                        generateNextQuestion();
                        resetValidationState();
                    }, 1500);
                } else {
                    const feedbackType = accuracy >= 50 ? "warning" : "incorrect";
                    const feedbackMessage = accuracy >= 50 
                        ? `${accuracy.toFixed(2)}% - Close! Adjust and retry` 
                        : `${accuracy.toFixed(2)}% - Needs improvement`;
                    
                    showFeedback(feedbackMessage, feedbackType);
                    resetValidationState();
                }

            } catch (error) {
                console.error('Validation error:', error);
                showFeedback("Validation error - Please retry", "warning");
                resetValidationState();
            }
        }

        function handleCorrectSubmission() {
            isHandwriteLocked = true;
            
            // Clear existing timeout
            if (currentTimeout) clearTimeout(currentTimeout);
            
            // Proceed after 1.5s
            currentTimeout = setTimeout(() => {
                generateNextQuestion();
                resetValidationState();
                isHandwriteLocked = false; // Reset lock for new question
            }, 1500);
        }


        function disableHandwriteControls(disabled) {
            document.querySelectorAll('.kanji-controls button').forEach(btn => {
                btn.disabled = disabled;
                btn.style.opacity = disabled ? 0.5 : 1;
            });
        }

        function resetValidationState() {
            window.isAnswered = false;
            isHandwriteLocked = false;
            disableHandwriteControls(false);
            strokes = [];
            resetCanvas();
        }

        function logStrokeDetails(kanjiData) {
            console.log("Expected Stroke Types:", kanjiData.strokeTypes);
            console.log("User Stroke Types:", 
                strokes.map(stroke => calculateStrokeType(stroke)));
            //console.log("Required Accuracy:", `${requiredStrokeAccuracy}%`);
        }

        // Stroke type classification system
        const StrokeTypes = {
            HORIZONTAL: 'HORIZONTAL',
            VERTICAL: 'VERTICAL',
            RIGHT_FALLING: 'RIGHT_FALLING',
            LEFT_FALLING: 'LEFT_FALLING',
            RIGHT_HOOK: 'RIGHT_HOOK',
            LEFT_HOOK: 'LEFT_HOOK',
            CURVE_RIGHT: 'CURVE_RIGHT',
            CURVE_LEFT: 'CURVE_LEFT',
            DOT: 'DOT',
            THROW: 'THROW',
            RISE: 'RISE',
            TICK: 'TICK',
            UNKNOWN: 'UNKNOWN'
        };

        const AnalysisConfig = {
            DOT_MAX_LENGTH: 0.075,  // 7.5% of canvas width
            HOOK_ANGLE_THRESHOLD: 60, // Degrees
            KEY_POINTS: 6, // Analyze 4 key points plus start/end

            CURVE_DEVIATION_THRESHOLD: 0.5, // Increased from 0.5
            MIN_CURVE_LENGTH: 0.2, // Minimum stroke length to qualify as curve
            CURVE_DIRECTION_ANGLE: 30 // Minimum angle for curve direction determination
        };

        function calculateAngleChange(prevPoint, currentPoint, nextPoint) {
            // Create vectors
            const vector1 = {
                x: currentPoint.x - prevPoint.x,
                y: currentPoint.y - prevPoint.y
            };
            
            const vector2 = {
                x: nextPoint.x - currentPoint.x,
                y: nextPoint.y - currentPoint.y
            };

            // Calculate angle between vectors
            const dotProduct = vector1.x * vector2.x + vector1.y * vector2.y;
            const magnitude1 = Math.hypot(vector1.x, vector1.y);
            const magnitude2 = Math.hypot(vector2.x, vector2.y);
            
            // Handle division by zero
            if (magnitude1 === 0 || magnitude2 === 0) return 0;
            
            const cosine = dotProduct / (magnitude1 * magnitude2);
            return Math.acos(Math.min(Math.max(cosine, -1), 1) * (180 / Math.PI));
        }

        // Enhanced stroke classification functions
        function classifyBasicStroke(keyPoints) {
            const dx = keyPoints[keyPoints.length - 1].x - keyPoints[0].x;
            const dy = keyPoints[keyPoints.length - 1].y - keyPoints[0].y;
            const angle = Math.atan2(dy, dx) * 180 / Math.PI;

            // Handle near-horizontal or vertical cases first.
            if (Math.abs(angle) < 15 || Math.abs(angle) > 165) return StrokeTypes.HORIZONTAL;
            if (Math.abs(angle - 90) < 15 || Math.abs(angle + 90) < 15) return StrokeTypes.VERTICAL;

            // For strokes going downward, decide based on horizontal change.
            if (dy > 0) {
                return dx > 0 ? StrokeTypes.RIGHT_FALLING : StrokeTypes.LEFT_FALLING;
            } else {
                // If the stroke is upward, you might swap or define separate rising types.
                return dx > 0 ? StrokeTypes.LEFT_FALLING : StrokeTypes.RIGHT_FALLING;
            }
        }

        function determineCurveType(keyPoints) {
            const start = keyPoints[0];
            const end = keyPoints[keyPoints.length-1];
            const mid = keyPoints[Math.floor(keyPoints.length/2)];
            
            // Calculate directional angles
            const mainAngle = Math.atan2(end.y - start.y, end.x - start.x);
            const deviationAngle = Math.atan2(mid.y - start.y, mid.x - start.x);
            
            // Calculate angle difference
            const angleDiff = deviationAngle - mainAngle;
            const degDiff = Math.abs(angleDiff * 180/Math.PI);

            if (degDiff < AnalysisConfig.CURVE_DIRECTION_ANGLE) return null;
            
            return angleDiff > 0 ? StrokeTypes.CURVE_RIGHT : StrokeTypes.CURVE_LEFT;
        }

        // Stroke compatibility matrix
        function directionMatches(expected, detected) {
            const compatibilityMatrix = {
                // Horizontal
                [StrokeTypes.HORIZONTAL]: [StrokeTypes.HORIZONTAL, StrokeTypes.TICK],
                
                // Vertical
                [StrokeTypes.VERTICAL]: [StrokeTypes.VERTICAL, StrokeTypes.RISE],
                
                // Right variations
                [StrokeTypes.RIGHT_FALLING]: [
                    StrokeTypes.RIGHT_FALLING,
                    StrokeTypes.CURVE_RIGHT,
                    StrokeTypes.THROW
                ],
                [StrokeTypes.RIGHT_HOOK]: [
                    StrokeTypes.RIGHT_HOOK,
                    StrokeTypes.RIGHT_FALLING
                ],
                
                // Left variations
                [StrokeTypes.LEFT_FALLING]: [
                    StrokeTypes.LEFT_FALLING,
                    StrokeTypes.CURVE_LEFT
                ],
                [StrokeTypes.LEFT_HOOK]: [
                    StrokeTypes.LEFT_HOOK,
                    StrokeTypes.LEFT_FALLING
                ],
                
                // Curves
                [StrokeTypes.CURVE_RIGHT]: [
                    StrokeTypes.CURVE_RIGHT,
                    StrokeTypes.RIGHT_FALLING
                ],
                [StrokeTypes.CURVE_LEFT]: [
                    StrokeTypes.CURVE_LEFT,
                    StrokeTypes.LEFT_FALLING
                ],
                
                // Special strokes
                [StrokeTypes.DOT]: [StrokeTypes.DOT],
                [StrokeTypes.THROW]: [StrokeTypes.THROW],
                [StrokeTypes.RISE]: [StrokeTypes.RISE]
            };

            const allowedTypes = compatibilityMatrix[expected] || [expected];
            return allowedTypes.includes(detected);
        }

        // Final verification of all dependencies
        const StrokeAnalysis = {
            calculateAngleChange,
            classifyBasicStroke,
            determineCurveType,
            getKeyAnalysisPoints,
            analyzeStroke,
            directionMatches
        };

        // 3. Core Stroke Analysis Function
        function analyzeStroke(points, canvasWidth) {
            if (!points || points.length < 2) return StrokeTypes.UNKNOWN;

            // Calculate basic metrics
            const start = points[0];
            const end = points[points.length-1];
            const dx = end.x - start.x;
            const dy = end.y - start.y;
            
            // 1. Dot Detection (dynamic size based on canvas)
            const maxDotLength = canvasWidth * AnalysisConfig.DOT_MAX_LENGTH;
            if (Math.hypot(dx, dy) < maxDotLength) {
                return StrokeTypes.DOT;
            }

            // 2. Identify Key Analysis Points
            const keyPoints = getKeyAnalysisPoints(points);
            
            // 3. Direction Change Analysis
            const directionChanges = analyzeDirectionChanges(keyPoints);
            
            // 4. Curve Analysis
            if (isCurve(keyPoints)) {
                const curveType = determineCurveType(keyPoints);
                if (curveType) return curveType;
            }

            // 5. Hook Detection
            const hookType = detectHookType(keyPoints);
            if (hookType) return hookType;

            // 6. Basic Stroke Classification
            return classifyBasicStroke(keyPoints);

            if (basicType === StrokeTypes.HORIZONTAL) {
                if (Math.abs(dy) > canvasWidth * 0.15) {
                return dy > 0 ? StrokeTypes.RIGHT_FALLING : StrokeTypes.LEFT_FALLING;
                }
            }

            if (basicType === StrokeTypes.VERTICAL) {
                if (Math.abs(dx) > canvasWidth * 0.15) {
                return dx > 0 ? StrokeTypes.RIGHT_FALLING : StrokeTypes.LEFT_FALLING;
                }
            }
            
            return basicType;
        }

        function calculateYVariance(points) {
            const yValues = points.map(p => p.y);
            const avgY = yValues.reduce((a,b) => a + b, 0) / yValues.length;
            return yValues.map(y => y - avgY).reduce((a,b) => a + Math.abs(b), 0);
        }

        // 4. Key Analysis Point Detection
        function getKeyAnalysisPoints(points) {
            const keyPoints = [points[0]]; // Start with initial point
            
            // Add intermediate points with largest direction changes
            const changes = points.slice(1, -1).map((p, i) => ({
                index: i+1,
                angleChange: calculateAngleChange(points[i], p, points[i+1])
            })).sort((a, b) => b.angleChange - a.angleChange);

            // Select top N changes
            const significantChanges = changes
                .filter(c => c.angleChange > AnalysisConfig.HOOK_ANGLE_THRESHOLD)
                .slice(0, AnalysisConfig.KEY_POINTS);

            // Add to key points
            significantChanges.forEach(c => keyPoints.push(points[c.index]));
            keyPoints.push(points[points.length-1]); // Add end point

            return keyPoints;
        }

        // 5. Direction Change Analysis
        function analyzeDirectionChanges(keyPoints) {
            const segments = [];
            for (let i = 1; i < keyPoints.length; i++) {
                const dx = keyPoints[i].x - keyPoints[i-1].x;
                const dy = keyPoints[i].y - keyPoints[i-1].y;
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                segments.push(angle);
            }
            return segments;
        }

        // 6. Curve Detection
        function isCurve(keyPoints) {
            const idealDX = keyPoints[keyPoints.length-1].x - keyPoints[0].x;
            const idealDY = keyPoints[keyPoints.length-1].y - keyPoints[0].y;
            
            // Only consider strokes longer than minimum curve length
            const strokeLength = Math.hypot(idealDX, idealDY);
            if (strokeLength < canvas.width * AnalysisConfig.MIN_CURVE_LENGTH) {
                return false;
            }

            let totalDeviation = 0;
            keyPoints.forEach(p => {
                const t = (p.x - keyPoints[0].x) / idealDX;
                const idealY = keyPoints[0].y + idealDY * t;
                totalDeviation += (p.y - idealY);
            });

            const normalizedDeviation = Math.abs(totalDeviation / keyPoints.length);
            return normalizedDeviation > (AnalysisConfig.CURVE_DEVIATION_THRESHOLD * Math.abs(idealDY));
        }

        // 7. Hook Detection
        function detectHookType(keyPoints) {
            if (keyPoints.length < 4) return null;
            
            const finalSegment = keyPoints.slice(-2);
            const finalDX = finalSegment[1].x - finalSegment[0].x;
            const finalDY = finalSegment[1].y - finalSegment[0].y;
            const finalAngle = Math.atan2(finalDY, finalDX) * 180 / Math.PI;

            if (Math.abs(finalAngle) > 100) return StrokeTypes.RIGHT_HOOK;
            if (Math.abs(finalAngle) < 80) return StrokeTypes.LEFT_HOOK;

            if (finalAngle > 45 && finalAngle < 135) {
                const penultimateSegment = keyPoints.slice(-3, -1);
                const penAngle = Math.atan2(
                penultimateSegment[1].y - penultimateSegment[0].y,
                penultimateSegment[1].x - penultimateSegment[0].x
                ) * 180/Math.PI;
                
                if (Math.abs(penAngle - finalAngle) > 45) {
                return StrokeTypes.CURVE_RIGHT;
                }
            }
            
            return null;
        }

        function validateKanjiStrokes(userStrokes, kanji) {
            const expectedStrokes = KanjiStrokeMap[kanji];
            if (!expectedStrokes || userStrokes.length !== expectedStrokes.length) {
                return 0;
            }

            let correctCount = 0;
            userStrokes.forEach((stroke, index) => {
                const detectedType = analyzeStroke(stroke.points, canvas.width);
                if (detectedType === expectedStrokes[index]) {
                    correctCount++;
                }
            });

            return (correctCount / expectedStrokes.length) * 100;
        }

        async function validateStrokeOrder(userStrokes, kanjiData) {
        try {
            const canvas = document.getElementById('kanjiCanvas');
            const allValidPatterns = [
            kanjiData.strokeTypes,
            ...(kanjiData.alternativeStrokeTypes || [])
            ];

            let bestAccuracy = 0;
            let bestPattern = null;
            let detectedTypes = [];

            // Validate against all patterns
            for (const pattern of allValidPatterns) {
            if (userStrokes.length !== pattern.length) continue;
            
            let correctCount = 0;
            const currentDetected = [];
            
            for (let i = 0; i < pattern.length; i++) {
                const detectedType = analyzeStroke(userStrokes[i], canvas.width);
                currentDetected.push(detectedType);
                if (directionMatches(pattern[i], detectedType)) {
                correctCount++;
                }
            }
            
            const accuracy = (correctCount / pattern.length) * 100;
            if (accuracy > bestAccuracy) {
                bestAccuracy = accuracy;
                bestPattern = pattern;
                detectedTypes = currentDetected;
            }
            }

            // Console logging
            console.groupCollapsed(`Stroke Validation for ${kanjiData.kanji}`);
            if (bestPattern) {
            console.log('Matching Pattern:', bestPattern === kanjiData.strokeTypes ? 
                'Official' : 'Alternative');
            
            console.table(bestPattern.map((expected, index) => ({
                'Stroke #': index + 1,
                'Expected': expected,
                'Detected': detectedTypes[index],
                'Match': directionMatches(expected, detectedTypes[index]) ? '✓' : '✗'
            })));
            
            console.log(`Final Accuracy: ${bestAccuracy.toFixed(2)}%`);
            } else {
            console.log('No matching stroke patterns found');
            }
            console.groupEnd();

            return bestAccuracy;

        } catch (error) {
            console.error('Validation error:', error);
            return 0;
        }
        }

        // Will open this when OCR adaption development began

        //async function validateWithOCR(imageData, expected) {
        //    try {
        //        const response = await fetch('/ocr-validate', {
        //            method: 'POST',
        //            headers: {'Content-Type': 'application/json'},
        //            body: JSON.stringify({
        //                image: imageData,
        //                expected: expected,
        //                lang: 'ja'
        //            })
        //        });
        //        return (await response.json()).result;
        //    } catch {
        //        return false;
        //    }
        //}

        function resetCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            strokes = [];
        }

        // Update progress bar
        function updateProgress() {
            const currentLesson = lessonProgress.find(lp => lp.code === currentCode);
            if (currentLesson) {
                const progress = (questionsCompleted / currentLesson.questionsPerLesson) * 100;
                document.getElementById('progressBar').style.width = `${progress}%`;
                
                // Update title and progress display
                document.title = `Livygo - ${currentLesson.title}`;
                const progressText = `${currentLesson.current}/${currentLesson.total}`;
                // Update your progress display element here
            }
        }

        // Complete lesson and update progress
        function completeLesson() {
            // Retrieve lesson progress from localStorage
            const storedProgress = JSON.parse(localStorage.getItem(`lessonProgress_${lang}`)) || [];
            const currentLesson = storedProgress.find(lp => lp.code === currentCode);

            if (currentLesson) {
                // Increase lesson count and save progress
                currentLesson.current = Math.min(currentLesson.current + 1, currentLesson.total);
                localStorage.setItem(`lessonProgress_${lang}`, JSON.stringify(storedProgress));
            }

            // Fade out and redirect back to main page
            document.body.classList.add('fade-out');
            setTimeout(() => window.location.href = 'mainnightly.html', 500);
        }
        
        // Show error message
        function showError(message) {
            const errorDiv = document.createElement('div');
            errorDiv.className = 'global-error';
            errorDiv.innerHTML = `
                <h3>Error</h3>
                <p>${message}</p>
            `;
            document.body.appendChild(errorDiv);
            setTimeout(() => errorDiv.remove(), 3000);
        }
    </script>
    <script src="codeParser.js"></script>
</body>
</html>